// **********************************************************************
//
// Copyright (c) 2003-2010 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

// Ice version 3.4.1

// <auto-generated>
//
// Generated from file `Murmur.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#ifndef __Murmur_h__
#define __Murmur_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <Ice/SliceChecksumDict.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Murmur
{

class Tree;

class ServerCallback;

class ServerContextCallback;

class ServerAuthenticator;

class ServerUpdatingAuthenticator;

class Server;

class MetaCallback;

class Meta;

}

}

namespace Murmur
{

class Tree;
bool operator==(const Tree&, const Tree&);
bool operator<(const Tree&, const Tree&);

class ServerCallback;
bool operator==(const ServerCallback&, const ServerCallback&);
bool operator<(const ServerCallback&, const ServerCallback&);

class ServerContextCallback;
bool operator==(const ServerContextCallback&, const ServerContextCallback&);
bool operator<(const ServerContextCallback&, const ServerContextCallback&);

class ServerAuthenticator;
bool operator==(const ServerAuthenticator&, const ServerAuthenticator&);
bool operator<(const ServerAuthenticator&, const ServerAuthenticator&);

class ServerUpdatingAuthenticator;
bool operator==(const ServerUpdatingAuthenticator&, const ServerUpdatingAuthenticator&);
bool operator<(const ServerUpdatingAuthenticator&, const ServerUpdatingAuthenticator&);

class Server;
bool operator==(const Server&, const Server&);
bool operator<(const Server&, const Server&);

class MetaCallback;
bool operator==(const MetaCallback&, const MetaCallback&);
bool operator<(const MetaCallback&, const MetaCallback&);

class Meta;
bool operator==(const Meta&, const Meta&);
bool operator<(const Meta&, const Meta&);

}

namespace IceInternal
{

::Ice::Object* upCast(::Murmur::Tree*);
::IceProxy::Ice::Object* upCast(::IceProxy::Murmur::Tree*);

::Ice::Object* upCast(::Murmur::ServerCallback*);
::IceProxy::Ice::Object* upCast(::IceProxy::Murmur::ServerCallback*);

::Ice::Object* upCast(::Murmur::ServerContextCallback*);
::IceProxy::Ice::Object* upCast(::IceProxy::Murmur::ServerContextCallback*);

::Ice::Object* upCast(::Murmur::ServerAuthenticator*);
::IceProxy::Ice::Object* upCast(::IceProxy::Murmur::ServerAuthenticator*);

::Ice::Object* upCast(::Murmur::ServerUpdatingAuthenticator*);
::IceProxy::Ice::Object* upCast(::IceProxy::Murmur::ServerUpdatingAuthenticator*);

::Ice::Object* upCast(::Murmur::Server*);
::IceProxy::Ice::Object* upCast(::IceProxy::Murmur::Server*);

::Ice::Object* upCast(::Murmur::MetaCallback*);
::IceProxy::Ice::Object* upCast(::IceProxy::Murmur::MetaCallback*);

::Ice::Object* upCast(::Murmur::Meta*);
::IceProxy::Ice::Object* upCast(::IceProxy::Murmur::Meta*);

}

namespace Murmur
{

typedef ::IceInternal::Handle< ::Murmur::Tree> TreePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Murmur::Tree> TreePrx;

void __read(::IceInternal::BasicStream*, TreePrx&);
void __patch__TreePtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::Murmur::ServerCallback> ServerCallbackPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Murmur::ServerCallback> ServerCallbackPrx;

void __read(::IceInternal::BasicStream*, ServerCallbackPrx&);
void __patch__ServerCallbackPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::Murmur::ServerContextCallback> ServerContextCallbackPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Murmur::ServerContextCallback> ServerContextCallbackPrx;

void __read(::IceInternal::BasicStream*, ServerContextCallbackPrx&);
void __patch__ServerContextCallbackPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::Murmur::ServerAuthenticator> ServerAuthenticatorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Murmur::ServerAuthenticator> ServerAuthenticatorPrx;

void __read(::IceInternal::BasicStream*, ServerAuthenticatorPrx&);
void __patch__ServerAuthenticatorPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::Murmur::ServerUpdatingAuthenticator> ServerUpdatingAuthenticatorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Murmur::ServerUpdatingAuthenticator> ServerUpdatingAuthenticatorPrx;

void __read(::IceInternal::BasicStream*, ServerUpdatingAuthenticatorPrx&);
void __patch__ServerUpdatingAuthenticatorPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::Murmur::Server> ServerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Murmur::Server> ServerPrx;

void __read(::IceInternal::BasicStream*, ServerPrx&);
void __patch__ServerPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::Murmur::MetaCallback> MetaCallbackPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Murmur::MetaCallback> MetaCallbackPrx;

void __read(::IceInternal::BasicStream*, MetaCallbackPrx&);
void __patch__MetaCallbackPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::Murmur::Meta> MetaPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Murmur::Meta> MetaPrx;

void __read(::IceInternal::BasicStream*, MetaPrx&);
void __patch__MetaPtr(void*, ::Ice::ObjectPtr&);

}

namespace Murmur
{

typedef ::std::vector< ::Ice::Byte> NetAddress;

struct User
{
    ::Ice::Int session;
    ::Ice::Int userid;
    bool mute;
    bool deaf;
    bool suppress;
    bool prioritySpeaker;
    bool selfMute;
    bool selfDeaf;
    bool recording;
    ::Ice::Int channel;
    ::std::string name;
    ::Ice::Int onlinesecs;
    ::Ice::Int bytespersec;
    ::Ice::Int version;
    ::std::string release;
    ::std::string os;
    ::std::string osversion;
    ::std::string identity;
    ::std::string context;
    ::std::string comment;
    ::Murmur::NetAddress address;
    bool tcponly;
    ::Ice::Int idlesecs;

    bool operator==(const User& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(session != __rhs.session)
        {
            return false;
        }
        if(userid != __rhs.userid)
        {
            return false;
        }
        if(mute != __rhs.mute)
        {
            return false;
        }
        if(deaf != __rhs.deaf)
        {
            return false;
        }
        if(suppress != __rhs.suppress)
        {
            return false;
        }
        if(prioritySpeaker != __rhs.prioritySpeaker)
        {
            return false;
        }
        if(selfMute != __rhs.selfMute)
        {
            return false;
        }
        if(selfDeaf != __rhs.selfDeaf)
        {
            return false;
        }
        if(recording != __rhs.recording)
        {
            return false;
        }
        if(channel != __rhs.channel)
        {
            return false;
        }
        if(name != __rhs.name)
        {
            return false;
        }
        if(onlinesecs != __rhs.onlinesecs)
        {
            return false;
        }
        if(bytespersec != __rhs.bytespersec)
        {
            return false;
        }
        if(version != __rhs.version)
        {
            return false;
        }
        if(release != __rhs.release)
        {
            return false;
        }
        if(os != __rhs.os)
        {
            return false;
        }
        if(osversion != __rhs.osversion)
        {
            return false;
        }
        if(identity != __rhs.identity)
        {
            return false;
        }
        if(context != __rhs.context)
        {
            return false;
        }
        if(comment != __rhs.comment)
        {
            return false;
        }
        if(address != __rhs.address)
        {
            return false;
        }
        if(tcponly != __rhs.tcponly)
        {
            return false;
        }
        if(idlesecs != __rhs.idlesecs)
        {
            return false;
        }
        return true;
    }

    bool operator<(const User& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(session < __rhs.session)
        {
            return true;
        }
        else if(__rhs.session < session)
        {
            return false;
        }
        if(userid < __rhs.userid)
        {
            return true;
        }
        else if(__rhs.userid < userid)
        {
            return false;
        }
        if(mute < __rhs.mute)
        {
            return true;
        }
        else if(__rhs.mute < mute)
        {
            return false;
        }
        if(deaf < __rhs.deaf)
        {
            return true;
        }
        else if(__rhs.deaf < deaf)
        {
            return false;
        }
        if(suppress < __rhs.suppress)
        {
            return true;
        }
        else if(__rhs.suppress < suppress)
        {
            return false;
        }
        if(prioritySpeaker < __rhs.prioritySpeaker)
        {
            return true;
        }
        else if(__rhs.prioritySpeaker < prioritySpeaker)
        {
            return false;
        }
        if(selfMute < __rhs.selfMute)
        {
            return true;
        }
        else if(__rhs.selfMute < selfMute)
        {
            return false;
        }
        if(selfDeaf < __rhs.selfDeaf)
        {
            return true;
        }
        else if(__rhs.selfDeaf < selfDeaf)
        {
            return false;
        }
        if(recording < __rhs.recording)
        {
            return true;
        }
        else if(__rhs.recording < recording)
        {
            return false;
        }
        if(channel < __rhs.channel)
        {
            return true;
        }
        else if(__rhs.channel < channel)
        {
            return false;
        }
        if(name < __rhs.name)
        {
            return true;
        }
        else if(__rhs.name < name)
        {
            return false;
        }
        if(onlinesecs < __rhs.onlinesecs)
        {
            return true;
        }
        else if(__rhs.onlinesecs < onlinesecs)
        {
            return false;
        }
        if(bytespersec < __rhs.bytespersec)
        {
            return true;
        }
        else if(__rhs.bytespersec < bytespersec)
        {
            return false;
        }
        if(version < __rhs.version)
        {
            return true;
        }
        else if(__rhs.version < version)
        {
            return false;
        }
        if(release < __rhs.release)
        {
            return true;
        }
        else if(__rhs.release < release)
        {
            return false;
        }
        if(os < __rhs.os)
        {
            return true;
        }
        else if(__rhs.os < os)
        {
            return false;
        }
        if(osversion < __rhs.osversion)
        {
            return true;
        }
        else if(__rhs.osversion < osversion)
        {
            return false;
        }
        if(identity < __rhs.identity)
        {
            return true;
        }
        else if(__rhs.identity < identity)
        {
            return false;
        }
        if(context < __rhs.context)
        {
            return true;
        }
        else if(__rhs.context < context)
        {
            return false;
        }
        if(comment < __rhs.comment)
        {
            return true;
        }
        else if(__rhs.comment < comment)
        {
            return false;
        }
        if(address < __rhs.address)
        {
            return true;
        }
        else if(__rhs.address < address)
        {
            return false;
        }
        if(tcponly < __rhs.tcponly)
        {
            return true;
        }
        else if(__rhs.tcponly < tcponly)
        {
            return false;
        }
        if(idlesecs < __rhs.idlesecs)
        {
            return true;
        }
        else if(__rhs.idlesecs < idlesecs)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const User& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const User& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const User& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const User& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::Ice::Int> IntList;

struct Channel
{
    ::Ice::Int id;
    ::std::string name;
    ::Ice::Int parent;
    ::Murmur::IntList links;
    ::std::string description;
    bool temporary;
    ::Ice::Int position;

    bool operator==(const Channel& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(id != __rhs.id)
        {
            return false;
        }
        if(name != __rhs.name)
        {
            return false;
        }
        if(parent != __rhs.parent)
        {
            return false;
        }
        if(links != __rhs.links)
        {
            return false;
        }
        if(description != __rhs.description)
        {
            return false;
        }
        if(temporary != __rhs.temporary)
        {
            return false;
        }
        if(position != __rhs.position)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Channel& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(id < __rhs.id)
        {
            return true;
        }
        else if(__rhs.id < id)
        {
            return false;
        }
        if(name < __rhs.name)
        {
            return true;
        }
        else if(__rhs.name < name)
        {
            return false;
        }
        if(parent < __rhs.parent)
        {
            return true;
        }
        else if(__rhs.parent < parent)
        {
            return false;
        }
        if(links < __rhs.links)
        {
            return true;
        }
        else if(__rhs.links < links)
        {
            return false;
        }
        if(description < __rhs.description)
        {
            return true;
        }
        else if(__rhs.description < description)
        {
            return false;
        }
        if(temporary < __rhs.temporary)
        {
            return true;
        }
        else if(__rhs.temporary < temporary)
        {
            return false;
        }
        if(position < __rhs.position)
        {
            return true;
        }
        else if(__rhs.position < position)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Channel& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Channel& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Channel& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Channel& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct Group
{
    ::std::string name;
    bool inherited;
    bool inherit;
    bool inheritable;
    ::Murmur::IntList add;
    ::Murmur::IntList remove;
    ::Murmur::IntList members;

    bool operator==(const Group& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(name != __rhs.name)
        {
            return false;
        }
        if(inherited != __rhs.inherited)
        {
            return false;
        }
        if(inherit != __rhs.inherit)
        {
            return false;
        }
        if(inheritable != __rhs.inheritable)
        {
            return false;
        }
        if(add != __rhs.add)
        {
            return false;
        }
        if(remove != __rhs.remove)
        {
            return false;
        }
        if(members != __rhs.members)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Group& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(name < __rhs.name)
        {
            return true;
        }
        else if(__rhs.name < name)
        {
            return false;
        }
        if(inherited < __rhs.inherited)
        {
            return true;
        }
        else if(__rhs.inherited < inherited)
        {
            return false;
        }
        if(inherit < __rhs.inherit)
        {
            return true;
        }
        else if(__rhs.inherit < inherit)
        {
            return false;
        }
        if(inheritable < __rhs.inheritable)
        {
            return true;
        }
        else if(__rhs.inheritable < inheritable)
        {
            return false;
        }
        if(add < __rhs.add)
        {
            return true;
        }
        else if(__rhs.add < add)
        {
            return false;
        }
        if(remove < __rhs.remove)
        {
            return true;
        }
        else if(__rhs.remove < remove)
        {
            return false;
        }
        if(members < __rhs.members)
        {
            return true;
        }
        else if(__rhs.members < members)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Group& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Group& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Group& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Group& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

const ::Ice::Int PermissionWrite = 1;

const ::Ice::Int PermissionTraverse = 2;

const ::Ice::Int PermissionEnter = 4;

const ::Ice::Int PermissionSpeak = 8;

const ::Ice::Int PermissionWhisper = 256;

const ::Ice::Int PermissionMuteDeafen = 16;

const ::Ice::Int PermissionMove = 32;

const ::Ice::Int PermissionMakeChannel = 64;

const ::Ice::Int PermissionMakeTempChannel = 1024;

const ::Ice::Int PermissionLinkChannel = 128;

const ::Ice::Int PermissionTextMessage = 512;

const ::Ice::Int PermissionKick = 65536;

const ::Ice::Int PermissionBan = 131072;

const ::Ice::Int PermissionRegister = 262144;

const ::Ice::Int PermissionRegisterSelf = 524288;

struct ACL
{
    bool applyHere;
    bool applySubs;
    bool inherited;
    ::Ice::Int userid;
    ::std::string group;
    ::Ice::Int allow;
    ::Ice::Int deny;

    bool operator==(const ACL& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(applyHere != __rhs.applyHere)
        {
            return false;
        }
        if(applySubs != __rhs.applySubs)
        {
            return false;
        }
        if(inherited != __rhs.inherited)
        {
            return false;
        }
        if(userid != __rhs.userid)
        {
            return false;
        }
        if(group != __rhs.group)
        {
            return false;
        }
        if(allow != __rhs.allow)
        {
            return false;
        }
        if(deny != __rhs.deny)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ACL& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(applyHere < __rhs.applyHere)
        {
            return true;
        }
        else if(__rhs.applyHere < applyHere)
        {
            return false;
        }
        if(applySubs < __rhs.applySubs)
        {
            return true;
        }
        else if(__rhs.applySubs < applySubs)
        {
            return false;
        }
        if(inherited < __rhs.inherited)
        {
            return true;
        }
        else if(__rhs.inherited < inherited)
        {
            return false;
        }
        if(userid < __rhs.userid)
        {
            return true;
        }
        else if(__rhs.userid < userid)
        {
            return false;
        }
        if(group < __rhs.group)
        {
            return true;
        }
        else if(__rhs.group < group)
        {
            return false;
        }
        if(allow < __rhs.allow)
        {
            return true;
        }
        else if(__rhs.allow < allow)
        {
            return false;
        }
        if(deny < __rhs.deny)
        {
            return true;
        }
        else if(__rhs.deny < deny)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ACL& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const ACL& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const ACL& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const ACL& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct Ban
{
    ::Murmur::NetAddress address;
    ::Ice::Int bits;
    ::std::string name;
    ::std::string hash;
    ::std::string reason;
    ::Ice::Int start;
    ::Ice::Int duration;

    bool operator==(const Ban& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(address != __rhs.address)
        {
            return false;
        }
        if(bits != __rhs.bits)
        {
            return false;
        }
        if(name != __rhs.name)
        {
            return false;
        }
        if(hash != __rhs.hash)
        {
            return false;
        }
        if(reason != __rhs.reason)
        {
            return false;
        }
        if(start != __rhs.start)
        {
            return false;
        }
        if(duration != __rhs.duration)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Ban& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(address < __rhs.address)
        {
            return true;
        }
        else if(__rhs.address < address)
        {
            return false;
        }
        if(bits < __rhs.bits)
        {
            return true;
        }
        else if(__rhs.bits < bits)
        {
            return false;
        }
        if(name < __rhs.name)
        {
            return true;
        }
        else if(__rhs.name < name)
        {
            return false;
        }
        if(hash < __rhs.hash)
        {
            return true;
        }
        else if(__rhs.hash < hash)
        {
            return false;
        }
        if(reason < __rhs.reason)
        {
            return true;
        }
        else if(__rhs.reason < reason)
        {
            return false;
        }
        if(start < __rhs.start)
        {
            return true;
        }
        else if(__rhs.start < start)
        {
            return false;
        }
        if(duration < __rhs.duration)
        {
            return true;
        }
        else if(__rhs.duration < duration)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Ban& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Ban& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Ban& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Ban& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct LogEntry
{
    ::Ice::Int timestamp;
    ::std::string txt;

    bool operator==(const LogEntry& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(timestamp != __rhs.timestamp)
        {
            return false;
        }
        if(txt != __rhs.txt)
        {
            return false;
        }
        return true;
    }

    bool operator<(const LogEntry& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(timestamp < __rhs.timestamp)
        {
            return true;
        }
        else if(__rhs.timestamp < timestamp)
        {
            return false;
        }
        if(txt < __rhs.txt)
        {
            return true;
        }
        else if(__rhs.txt < txt)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const LogEntry& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const LogEntry& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const LogEntry& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const LogEntry& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::Murmur::TreePtr> TreeList;
void __writeTreeList(::IceInternal::BasicStream*, const ::Murmur::TreePtr*, const ::Murmur::TreePtr*);
void __readTreeList(::IceInternal::BasicStream*, TreeList&);

enum ChannelInfo
{
    ChannelDescription,
    ChannelPosition
};

void __write(::IceInternal::BasicStream*, ChannelInfo);
void __read(::IceInternal::BasicStream*, ChannelInfo&);

enum UserInfo
{
    UserName,
    UserEmail,
    UserComment,
    UserHash,
    UserPassword,
    UserLastActive
};

void __write(::IceInternal::BasicStream*, UserInfo);
void __read(::IceInternal::BasicStream*, UserInfo&);

typedef ::std::map< ::Ice::Int, ::Murmur::User> UserMap;
void __writeUserMap(::IceInternal::BasicStream*, const UserMap&);
void __readUserMap(::IceInternal::BasicStream*, UserMap&);

typedef ::std::map< ::Ice::Int, ::Murmur::Channel> ChannelMap;
void __writeChannelMap(::IceInternal::BasicStream*, const ChannelMap&);
void __readChannelMap(::IceInternal::BasicStream*, ChannelMap&);

typedef ::std::vector< ::Murmur::Channel> ChannelList;
void __writeChannelList(::IceInternal::BasicStream*, const ::Murmur::Channel*, const ::Murmur::Channel*);
void __readChannelList(::IceInternal::BasicStream*, ChannelList&);

typedef ::std::vector< ::Murmur::User> UserList;
void __writeUserList(::IceInternal::BasicStream*, const ::Murmur::User*, const ::Murmur::User*);
void __readUserList(::IceInternal::BasicStream*, UserList&);

typedef ::std::vector< ::Murmur::Group> GroupList;
void __writeGroupList(::IceInternal::BasicStream*, const ::Murmur::Group*, const ::Murmur::Group*);
void __readGroupList(::IceInternal::BasicStream*, GroupList&);

typedef ::std::vector< ::Murmur::ACL> ACLList;
void __writeACLList(::IceInternal::BasicStream*, const ::Murmur::ACL*, const ::Murmur::ACL*);
void __readACLList(::IceInternal::BasicStream*, ACLList&);

typedef ::std::vector< ::Murmur::LogEntry> LogList;
void __writeLogList(::IceInternal::BasicStream*, const ::Murmur::LogEntry*, const ::Murmur::LogEntry*);
void __readLogList(::IceInternal::BasicStream*, LogList&);

typedef ::std::vector< ::Murmur::Ban> BanList;
void __writeBanList(::IceInternal::BasicStream*, const ::Murmur::Ban*, const ::Murmur::Ban*);
void __readBanList(::IceInternal::BasicStream*, BanList&);

typedef ::std::vector< ::Ice::Int> IdList;

typedef ::std::vector< ::std::string> NameList;

typedef ::std::map< ::Ice::Int, ::std::string> NameMap;
void __writeNameMap(::IceInternal::BasicStream*, const NameMap&);
void __readNameMap(::IceInternal::BasicStream*, NameMap&);

typedef ::std::map< ::std::string, ::Ice::Int> IdMap;
void __writeIdMap(::IceInternal::BasicStream*, const IdMap&);
void __readIdMap(::IceInternal::BasicStream*, IdMap&);

typedef ::std::vector< ::Ice::Byte> Texture;

typedef ::std::map< ::std::string, ::std::string> ConfigMap;
void __writeConfigMap(::IceInternal::BasicStream*, const ConfigMap&);
void __readConfigMap(::IceInternal::BasicStream*, ConfigMap&);

typedef ::std::vector< ::std::string> GroupNameList;

typedef ::std::vector< ::Ice::Byte> CertificateDer;

typedef ::std::vector< ::Murmur::CertificateDer> CertificateList;
void __writeCertificateList(::IceInternal::BasicStream*, const ::Murmur::CertificateDer*, const ::Murmur::CertificateDer*);
void __readCertificateList(::IceInternal::BasicStream*, CertificateList&);

typedef ::std::map< ::Murmur::UserInfo, ::std::string> UserInfoMap;
void __writeUserInfoMap(::IceInternal::BasicStream*, const UserInfoMap&);
void __readUserInfoMap(::IceInternal::BasicStream*, UserInfoMap&);

class MurmurException : public ::Ice::UserException
{
public:

    MurmurException() {}
    virtual ~MurmurException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

static MurmurException __MurmurException_init;

class InvalidSessionException : public ::Murmur::MurmurException
{
public:

    InvalidSessionException() {}
    virtual ~InvalidSessionException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class InvalidChannelException : public ::Murmur::MurmurException
{
public:

    InvalidChannelException() {}
    virtual ~InvalidChannelException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class InvalidServerException : public ::Murmur::MurmurException
{
public:

    InvalidServerException() {}
    virtual ~InvalidServerException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class ServerBootedException : public ::Murmur::MurmurException
{
public:

    ServerBootedException() {}
    virtual ~ServerBootedException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class ServerFailureException : public ::Murmur::MurmurException
{
public:

    ServerFailureException() {}
    virtual ~ServerFailureException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class InvalidUserException : public ::Murmur::MurmurException
{
public:

    InvalidUserException() {}
    virtual ~InvalidUserException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class InvalidTextureException : public ::Murmur::MurmurException
{
public:

    InvalidTextureException() {}
    virtual ~InvalidTextureException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class InvalidCallbackException : public ::Murmur::MurmurException
{
public:

    InvalidCallbackException() {}
    virtual ~InvalidCallbackException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class InvalidSecretException : public ::Murmur::MurmurException
{
public:

    InvalidSecretException() {}
    virtual ~InvalidSecretException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

const ::Ice::Int ContextServer = 1;

const ::Ice::Int ContextChannel = 2;

const ::Ice::Int ContextUser = 4;

typedef ::std::vector< ::Murmur::ServerPrx> ServerList;
void __writeServerList(::IceInternal::BasicStream*, const ::Murmur::ServerPrx*, const ::Murmur::ServerPrx*);
void __readServerList(::IceInternal::BasicStream*, ServerList&);

}

namespace Murmur
{

class AMD_Server_isRunning : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(bool) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_isRunning> AMD_Server_isRunningPtr;

class AMD_Server_start : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_start> AMD_Server_startPtr;

class AMD_Server_stop : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_stop> AMD_Server_stopPtr;

class AMD_Server_delete : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_delete> AMD_Server_deletePtr;

class AMD_Server_id : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_id> AMD_Server_idPtr;

class AMD_Server_addCallback : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_addCallback> AMD_Server_addCallbackPtr;

class AMD_Server_removeCallback : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_removeCallback> AMD_Server_removeCallbackPtr;

class AMD_Server_setAuthenticator : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_setAuthenticator> AMD_Server_setAuthenticatorPtr;

class AMD_Server_getConf : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::std::string&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getConf> AMD_Server_getConfPtr;

class AMD_Server_getAllConf : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::ConfigMap&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getAllConf> AMD_Server_getAllConfPtr;

class AMD_Server_setConf : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_setConf> AMD_Server_setConfPtr;

class AMD_Server_setSuperuserPassword : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_setSuperuserPassword> AMD_Server_setSuperuserPasswordPtr;

class AMD_Server_getLog : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::LogList&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getLog> AMD_Server_getLogPtr;

class AMD_Server_getLogLen : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getLogLen> AMD_Server_getLogLenPtr;

class AMD_Server_getUsers : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::UserMap&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getUsers> AMD_Server_getUsersPtr;

class AMD_Server_getChannels : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::ChannelMap&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getChannels> AMD_Server_getChannelsPtr;

class AMD_Server_getCertificateList : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::CertificateList&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getCertificateList> AMD_Server_getCertificateListPtr;

class AMD_Server_getTree : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::TreePtr&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getTree> AMD_Server_getTreePtr;

class AMD_Server_getBans : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::BanList&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getBans> AMD_Server_getBansPtr;

class AMD_Server_setBans : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_setBans> AMD_Server_setBansPtr;

class AMD_Server_kickUser : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_kickUser> AMD_Server_kickUserPtr;

class AMD_Server_getState : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::User&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getState> AMD_Server_getStatePtr;

class AMD_Server_setState : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_setState> AMD_Server_setStatePtr;

class AMD_Server_sendMessage : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_sendMessage> AMD_Server_sendMessagePtr;

class AMD_Server_hasPermission : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(bool) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_hasPermission> AMD_Server_hasPermissionPtr;

class AMD_Server_addContextCallback : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_addContextCallback> AMD_Server_addContextCallbackPtr;

class AMD_Server_removeContextCallback : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_removeContextCallback> AMD_Server_removeContextCallbackPtr;

class AMD_Server_getChannelState : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::Channel&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getChannelState> AMD_Server_getChannelStatePtr;

class AMD_Server_setChannelState : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_setChannelState> AMD_Server_setChannelStatePtr;

class AMD_Server_removeChannel : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_removeChannel> AMD_Server_removeChannelPtr;

class AMD_Server_addChannel : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_addChannel> AMD_Server_addChannelPtr;

class AMD_Server_sendMessageChannel : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_sendMessageChannel> AMD_Server_sendMessageChannelPtr;

class AMD_Server_getACL : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getACL> AMD_Server_getACLPtr;

class AMD_Server_setACL : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_setACL> AMD_Server_setACLPtr;

class AMD_Server_addUserToGroup : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_addUserToGroup> AMD_Server_addUserToGroupPtr;

class AMD_Server_removeUserFromGroup : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_removeUserFromGroup> AMD_Server_removeUserFromGroupPtr;

class AMD_Server_redirectWhisperGroup : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_redirectWhisperGroup> AMD_Server_redirectWhisperGroupPtr;

class AMD_Server_getUserNames : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::NameMap&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getUserNames> AMD_Server_getUserNamesPtr;

class AMD_Server_getUserIds : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::IdMap&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getUserIds> AMD_Server_getUserIdsPtr;

class AMD_Server_registerUser : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_registerUser> AMD_Server_registerUserPtr;

class AMD_Server_unregisterUser : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_unregisterUser> AMD_Server_unregisterUserPtr;

class AMD_Server_updateRegistration : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_updateRegistration> AMD_Server_updateRegistrationPtr;

class AMD_Server_getRegistration : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::UserInfoMap&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getRegistration> AMD_Server_getRegistrationPtr;

class AMD_Server_getRegisteredUsers : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::NameMap&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getRegisteredUsers> AMD_Server_getRegisteredUsersPtr;

class AMD_Server_verifyPassword : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_verifyPassword> AMD_Server_verifyPasswordPtr;

class AMD_Server_getTexture : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::Texture&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getTexture> AMD_Server_getTexturePtr;

class AMD_Server_setTexture : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_setTexture> AMD_Server_setTexturePtr;

class AMD_Server_getUptime : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Server_getUptime> AMD_Server_getUptimePtr;

class AMD_Meta_getServer : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::ServerPrx&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Meta_getServer> AMD_Meta_getServerPtr;

class AMD_Meta_newServer : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::ServerPrx&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Meta_newServer> AMD_Meta_newServerPtr;

class AMD_Meta_getBootedServers : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::ServerList&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Meta_getBootedServers> AMD_Meta_getBootedServersPtr;

class AMD_Meta_getAllServers : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::ServerList&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Meta_getAllServers> AMD_Meta_getAllServersPtr;

class AMD_Meta_getDefaultConf : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Murmur::ConfigMap&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Meta_getDefaultConf> AMD_Meta_getDefaultConfPtr;

class AMD_Meta_getVersion : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::std::string&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Meta_getVersion> AMD_Meta_getVersionPtr;

class AMD_Meta_addCallback : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Meta_addCallback> AMD_Meta_addCallbackPtr;

class AMD_Meta_removeCallback : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Meta_removeCallback> AMD_Meta_removeCallbackPtr;

class AMD_Meta_getUptime : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Meta_getUptime> AMD_Meta_getUptimePtr;

class AMD_Meta_getSlice : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::std::string&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Meta_getSlice> AMD_Meta_getSlicePtr;

class AMD_Meta_getSliceChecksums : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Ice::SliceChecksumDict&) = 0;
};

typedef ::IceUtil::Handle< ::Murmur::AMD_Meta_getSliceChecksums> AMD_Meta_getSliceChecksumsPtr;

}

namespace IceAsync
{

namespace Murmur
{

class AMD_Server_isRunning : public ::Murmur::AMD_Server_isRunning, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_isRunning(::IceInternal::Incoming&);

    virtual void ice_response(bool);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_start : public ::Murmur::AMD_Server_start, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_start(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_stop : public ::Murmur::AMD_Server_stop, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_stop(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_delete : public ::Murmur::AMD_Server_delete, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_delete(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_id : public ::Murmur::AMD_Server_id, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_id(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_addCallback : public ::Murmur::AMD_Server_addCallback, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_addCallback(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_removeCallback : public ::Murmur::AMD_Server_removeCallback, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_removeCallback(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_setAuthenticator : public ::Murmur::AMD_Server_setAuthenticator, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_setAuthenticator(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getConf : public ::Murmur::AMD_Server_getConf, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getConf(::IceInternal::Incoming&);

    virtual void ice_response(const ::std::string&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getAllConf : public ::Murmur::AMD_Server_getAllConf, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getAllConf(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::ConfigMap&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_setConf : public ::Murmur::AMD_Server_setConf, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_setConf(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_setSuperuserPassword : public ::Murmur::AMD_Server_setSuperuserPassword, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_setSuperuserPassword(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getLog : public ::Murmur::AMD_Server_getLog, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getLog(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::LogList&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getLogLen : public ::Murmur::AMD_Server_getLogLen, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getLogLen(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getUsers : public ::Murmur::AMD_Server_getUsers, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getUsers(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::UserMap&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getChannels : public ::Murmur::AMD_Server_getChannels, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getChannels(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::ChannelMap&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getCertificateList : public ::Murmur::AMD_Server_getCertificateList, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getCertificateList(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::CertificateList&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getTree : public ::Murmur::AMD_Server_getTree, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getTree(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::TreePtr&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getBans : public ::Murmur::AMD_Server_getBans, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getBans(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::BanList&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_setBans : public ::Murmur::AMD_Server_setBans, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_setBans(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_kickUser : public ::Murmur::AMD_Server_kickUser, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_kickUser(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getState : public ::Murmur::AMD_Server_getState, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getState(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::User&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_setState : public ::Murmur::AMD_Server_setState, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_setState(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_sendMessage : public ::Murmur::AMD_Server_sendMessage, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_sendMessage(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_hasPermission : public ::Murmur::AMD_Server_hasPermission, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_hasPermission(::IceInternal::Incoming&);

    virtual void ice_response(bool);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_addContextCallback : public ::Murmur::AMD_Server_addContextCallback, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_addContextCallback(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_removeContextCallback : public ::Murmur::AMD_Server_removeContextCallback, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_removeContextCallback(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getChannelState : public ::Murmur::AMD_Server_getChannelState, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getChannelState(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::Channel&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_setChannelState : public ::Murmur::AMD_Server_setChannelState, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_setChannelState(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_removeChannel : public ::Murmur::AMD_Server_removeChannel, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_removeChannel(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_addChannel : public ::Murmur::AMD_Server_addChannel, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_addChannel(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_sendMessageChannel : public ::Murmur::AMD_Server_sendMessageChannel, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_sendMessageChannel(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getACL : public ::Murmur::AMD_Server_getACL, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getACL(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_setACL : public ::Murmur::AMD_Server_setACL, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_setACL(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_addUserToGroup : public ::Murmur::AMD_Server_addUserToGroup, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_addUserToGroup(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_removeUserFromGroup : public ::Murmur::AMD_Server_removeUserFromGroup, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_removeUserFromGroup(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_redirectWhisperGroup : public ::Murmur::AMD_Server_redirectWhisperGroup, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_redirectWhisperGroup(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getUserNames : public ::Murmur::AMD_Server_getUserNames, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getUserNames(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::NameMap&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getUserIds : public ::Murmur::AMD_Server_getUserIds, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getUserIds(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::IdMap&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_registerUser : public ::Murmur::AMD_Server_registerUser, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_registerUser(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_unregisterUser : public ::Murmur::AMD_Server_unregisterUser, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_unregisterUser(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_updateRegistration : public ::Murmur::AMD_Server_updateRegistration, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_updateRegistration(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getRegistration : public ::Murmur::AMD_Server_getRegistration, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getRegistration(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::UserInfoMap&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getRegisteredUsers : public ::Murmur::AMD_Server_getRegisteredUsers, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getRegisteredUsers(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::NameMap&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_verifyPassword : public ::Murmur::AMD_Server_verifyPassword, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_verifyPassword(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getTexture : public ::Murmur::AMD_Server_getTexture, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getTexture(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::Texture&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_setTexture : public ::Murmur::AMD_Server_setTexture, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_setTexture(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Server_getUptime : public ::Murmur::AMD_Server_getUptime, public ::IceInternal::IncomingAsync
{
public:

    AMD_Server_getUptime(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Meta_getServer : public ::Murmur::AMD_Meta_getServer, public ::IceInternal::IncomingAsync
{
public:

    AMD_Meta_getServer(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::ServerPrx&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Meta_newServer : public ::Murmur::AMD_Meta_newServer, public ::IceInternal::IncomingAsync
{
public:

    AMD_Meta_newServer(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::ServerPrx&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Meta_getBootedServers : public ::Murmur::AMD_Meta_getBootedServers, public ::IceInternal::IncomingAsync
{
public:

    AMD_Meta_getBootedServers(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::ServerList&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Meta_getAllServers : public ::Murmur::AMD_Meta_getAllServers, public ::IceInternal::IncomingAsync
{
public:

    AMD_Meta_getAllServers(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::ServerList&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Meta_getDefaultConf : public ::Murmur::AMD_Meta_getDefaultConf, public ::IceInternal::IncomingAsync
{
public:

    AMD_Meta_getDefaultConf(::IceInternal::Incoming&);

    virtual void ice_response(const ::Murmur::ConfigMap&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Meta_getVersion : public ::Murmur::AMD_Meta_getVersion, public ::IceInternal::IncomingAsync
{
public:

    AMD_Meta_getVersion(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::std::string&);
};

class AMD_Meta_addCallback : public ::Murmur::AMD_Meta_addCallback, public ::IceInternal::IncomingAsync
{
public:

    AMD_Meta_addCallback(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Meta_removeCallback : public ::Murmur::AMD_Meta_removeCallback, public ::IceInternal::IncomingAsync
{
public:

    AMD_Meta_removeCallback(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Meta_getUptime : public ::Murmur::AMD_Meta_getUptime, public ::IceInternal::IncomingAsync
{
public:

    AMD_Meta_getUptime(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
};

class AMD_Meta_getSlice : public ::Murmur::AMD_Meta_getSlice, public ::IceInternal::IncomingAsync
{
public:

    AMD_Meta_getSlice(::IceInternal::Incoming&);

    virtual void ice_response(const ::std::string&);
};

class AMD_Meta_getSliceChecksums : public ::Murmur::AMD_Meta_getSliceChecksums, public ::IceInternal::IncomingAsync
{
public:

    AMD_Meta_getSliceChecksums(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::SliceChecksumDict&);
};

}

}

namespace Murmur
{

class Callback_ServerCallback_userConnected_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerCallback_userConnected_Base> Callback_ServerCallback_userConnectedPtr;

class Callback_ServerCallback_userDisconnected_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerCallback_userDisconnected_Base> Callback_ServerCallback_userDisconnectedPtr;

class Callback_ServerCallback_userStateChanged_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerCallback_userStateChanged_Base> Callback_ServerCallback_userStateChangedPtr;

class Callback_ServerCallback_channelCreated_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerCallback_channelCreated_Base> Callback_ServerCallback_channelCreatedPtr;

class Callback_ServerCallback_channelRemoved_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerCallback_channelRemoved_Base> Callback_ServerCallback_channelRemovedPtr;

class Callback_ServerCallback_channelStateChanged_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerCallback_channelStateChanged_Base> Callback_ServerCallback_channelStateChangedPtr;

class Callback_ServerContextCallback_contextAction_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerContextCallback_contextAction_Base> Callback_ServerContextCallback_contextActionPtr;

class Callback_ServerAuthenticator_authenticate_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAuthenticator_authenticate_Base> Callback_ServerAuthenticator_authenticatePtr;

class Callback_ServerAuthenticator_getInfo_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAuthenticator_getInfo_Base> Callback_ServerAuthenticator_getInfoPtr;

class Callback_ServerAuthenticator_nameToId_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAuthenticator_nameToId_Base> Callback_ServerAuthenticator_nameToIdPtr;

class Callback_ServerAuthenticator_idToName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAuthenticator_idToName_Base> Callback_ServerAuthenticator_idToNamePtr;

class Callback_ServerAuthenticator_idToTexture_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAuthenticator_idToTexture_Base> Callback_ServerAuthenticator_idToTexturePtr;

class Callback_ServerUpdatingAuthenticator_registerUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerUpdatingAuthenticator_registerUser_Base> Callback_ServerUpdatingAuthenticator_registerUserPtr;

class Callback_ServerUpdatingAuthenticator_unregisterUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerUpdatingAuthenticator_unregisterUser_Base> Callback_ServerUpdatingAuthenticator_unregisterUserPtr;

class Callback_ServerUpdatingAuthenticator_getRegisteredUsers_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerUpdatingAuthenticator_getRegisteredUsers_Base> Callback_ServerUpdatingAuthenticator_getRegisteredUsersPtr;

class Callback_ServerUpdatingAuthenticator_setInfo_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerUpdatingAuthenticator_setInfo_Base> Callback_ServerUpdatingAuthenticator_setInfoPtr;

class Callback_ServerUpdatingAuthenticator_setTexture_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerUpdatingAuthenticator_setTexture_Base> Callback_ServerUpdatingAuthenticator_setTexturePtr;

class Callback_Server_isRunning_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_isRunning_Base> Callback_Server_isRunningPtr;

class Callback_Server_start_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_start_Base> Callback_Server_startPtr;

class Callback_Server_stop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_stop_Base> Callback_Server_stopPtr;

class Callback_Server_delete_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_delete_Base> Callback_Server_deletePtr;

class Callback_Server_id_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_id_Base> Callback_Server_idPtr;

class Callback_Server_addCallback_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_addCallback_Base> Callback_Server_addCallbackPtr;

class Callback_Server_removeCallback_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_removeCallback_Base> Callback_Server_removeCallbackPtr;

class Callback_Server_setAuthenticator_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_setAuthenticator_Base> Callback_Server_setAuthenticatorPtr;

class Callback_Server_getConf_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getConf_Base> Callback_Server_getConfPtr;

class Callback_Server_getAllConf_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getAllConf_Base> Callback_Server_getAllConfPtr;

class Callback_Server_setConf_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_setConf_Base> Callback_Server_setConfPtr;

class Callback_Server_setSuperuserPassword_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_setSuperuserPassword_Base> Callback_Server_setSuperuserPasswordPtr;

class Callback_Server_getLog_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getLog_Base> Callback_Server_getLogPtr;

class Callback_Server_getLogLen_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getLogLen_Base> Callback_Server_getLogLenPtr;

class Callback_Server_getUsers_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getUsers_Base> Callback_Server_getUsersPtr;

class Callback_Server_getChannels_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getChannels_Base> Callback_Server_getChannelsPtr;

class Callback_Server_getCertificateList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getCertificateList_Base> Callback_Server_getCertificateListPtr;

class Callback_Server_getTree_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getTree_Base> Callback_Server_getTreePtr;

class Callback_Server_getBans_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getBans_Base> Callback_Server_getBansPtr;

class Callback_Server_setBans_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_setBans_Base> Callback_Server_setBansPtr;

class Callback_Server_kickUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_kickUser_Base> Callback_Server_kickUserPtr;

class Callback_Server_getState_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getState_Base> Callback_Server_getStatePtr;

class Callback_Server_setState_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_setState_Base> Callback_Server_setStatePtr;

class Callback_Server_sendMessage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_sendMessage_Base> Callback_Server_sendMessagePtr;

class Callback_Server_hasPermission_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_hasPermission_Base> Callback_Server_hasPermissionPtr;

class Callback_Server_addContextCallback_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_addContextCallback_Base> Callback_Server_addContextCallbackPtr;

class Callback_Server_removeContextCallback_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_removeContextCallback_Base> Callback_Server_removeContextCallbackPtr;

class Callback_Server_getChannelState_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getChannelState_Base> Callback_Server_getChannelStatePtr;

class Callback_Server_setChannelState_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_setChannelState_Base> Callback_Server_setChannelStatePtr;

class Callback_Server_removeChannel_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_removeChannel_Base> Callback_Server_removeChannelPtr;

class Callback_Server_addChannel_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_addChannel_Base> Callback_Server_addChannelPtr;

class Callback_Server_sendMessageChannel_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_sendMessageChannel_Base> Callback_Server_sendMessageChannelPtr;

class Callback_Server_getACL_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getACL_Base> Callback_Server_getACLPtr;

class Callback_Server_setACL_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_setACL_Base> Callback_Server_setACLPtr;

class Callback_Server_addUserToGroup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_addUserToGroup_Base> Callback_Server_addUserToGroupPtr;

class Callback_Server_removeUserFromGroup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_removeUserFromGroup_Base> Callback_Server_removeUserFromGroupPtr;

class Callback_Server_redirectWhisperGroup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_redirectWhisperGroup_Base> Callback_Server_redirectWhisperGroupPtr;

class Callback_Server_getUserNames_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getUserNames_Base> Callback_Server_getUserNamesPtr;

class Callback_Server_getUserIds_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getUserIds_Base> Callback_Server_getUserIdsPtr;

class Callback_Server_registerUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_registerUser_Base> Callback_Server_registerUserPtr;

class Callback_Server_unregisterUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_unregisterUser_Base> Callback_Server_unregisterUserPtr;

class Callback_Server_updateRegistration_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_updateRegistration_Base> Callback_Server_updateRegistrationPtr;

class Callback_Server_getRegistration_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getRegistration_Base> Callback_Server_getRegistrationPtr;

class Callback_Server_getRegisteredUsers_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getRegisteredUsers_Base> Callback_Server_getRegisteredUsersPtr;

class Callback_Server_verifyPassword_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_verifyPassword_Base> Callback_Server_verifyPasswordPtr;

class Callback_Server_getTexture_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getTexture_Base> Callback_Server_getTexturePtr;

class Callback_Server_setTexture_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_setTexture_Base> Callback_Server_setTexturePtr;

class Callback_Server_getUptime_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getUptime_Base> Callback_Server_getUptimePtr;

class Callback_MetaCallback_started_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MetaCallback_started_Base> Callback_MetaCallback_startedPtr;

class Callback_MetaCallback_stopped_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MetaCallback_stopped_Base> Callback_MetaCallback_stoppedPtr;

class Callback_Meta_getServer_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Meta_getServer_Base> Callback_Meta_getServerPtr;

class Callback_Meta_newServer_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Meta_newServer_Base> Callback_Meta_newServerPtr;

class Callback_Meta_getBootedServers_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Meta_getBootedServers_Base> Callback_Meta_getBootedServersPtr;

class Callback_Meta_getAllServers_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Meta_getAllServers_Base> Callback_Meta_getAllServersPtr;

class Callback_Meta_getDefaultConf_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Meta_getDefaultConf_Base> Callback_Meta_getDefaultConfPtr;

class Callback_Meta_getVersion_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Meta_getVersion_Base> Callback_Meta_getVersionPtr;

class Callback_Meta_addCallback_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Meta_addCallback_Base> Callback_Meta_addCallbackPtr;

class Callback_Meta_removeCallback_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Meta_removeCallback_Base> Callback_Meta_removeCallbackPtr;

class Callback_Meta_getUptime_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Meta_getUptime_Base> Callback_Meta_getUptimePtr;

class Callback_Meta_getSlice_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Meta_getSlice_Base> Callback_Meta_getSlicePtr;

class Callback_Meta_getSliceChecksums_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Meta_getSliceChecksums_Base> Callback_Meta_getSliceChecksumsPtr;

}

namespace IceProxy
{

namespace Murmur
{

class Tree : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Tree> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Tree> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Tree*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<Tree*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ServerCallback : virtual public ::IceProxy::Ice::Object
{
public:

    void userConnected(const ::Murmur::User& state)
    {
        userConnected(state, 0);
    }
    void userConnected(const ::Murmur::User& state, const ::Ice::Context& __ctx)
    {
        userConnected(state, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_userConnected(const ::Murmur::User& state)
    {
        return begin_userConnected(state, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_userConnected(const ::Murmur::User& state, const ::Ice::Context& __ctx)
    {
        return begin_userConnected(state, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_userConnected(const ::Murmur::User& state, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userConnected(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userConnected(const ::Murmur::User& state, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userConnected(state, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userConnected(const ::Murmur::User& state, const ::Murmur::Callback_ServerCallback_userConnectedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userConnected(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userConnected(const ::Murmur::User& state, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerCallback_userConnectedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userConnected(state, &__ctx, __del, __cookie);
    }

    void end_userConnected(const ::Ice::AsyncResultPtr&);
    
private:

    void userConnected(const ::Murmur::User&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_userConnected(const ::Murmur::User&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void userDisconnected(const ::Murmur::User& state)
    {
        userDisconnected(state, 0);
    }
    void userDisconnected(const ::Murmur::User& state, const ::Ice::Context& __ctx)
    {
        userDisconnected(state, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_userDisconnected(const ::Murmur::User& state)
    {
        return begin_userDisconnected(state, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_userDisconnected(const ::Murmur::User& state, const ::Ice::Context& __ctx)
    {
        return begin_userDisconnected(state, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_userDisconnected(const ::Murmur::User& state, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userDisconnected(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userDisconnected(const ::Murmur::User& state, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userDisconnected(state, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userDisconnected(const ::Murmur::User& state, const ::Murmur::Callback_ServerCallback_userDisconnectedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userDisconnected(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userDisconnected(const ::Murmur::User& state, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerCallback_userDisconnectedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userDisconnected(state, &__ctx, __del, __cookie);
    }

    void end_userDisconnected(const ::Ice::AsyncResultPtr&);
    
private:

    void userDisconnected(const ::Murmur::User&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_userDisconnected(const ::Murmur::User&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void userStateChanged(const ::Murmur::User& state)
    {
        userStateChanged(state, 0);
    }
    void userStateChanged(const ::Murmur::User& state, const ::Ice::Context& __ctx)
    {
        userStateChanged(state, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_userStateChanged(const ::Murmur::User& state)
    {
        return begin_userStateChanged(state, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_userStateChanged(const ::Murmur::User& state, const ::Ice::Context& __ctx)
    {
        return begin_userStateChanged(state, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_userStateChanged(const ::Murmur::User& state, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userStateChanged(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userStateChanged(const ::Murmur::User& state, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userStateChanged(state, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userStateChanged(const ::Murmur::User& state, const ::Murmur::Callback_ServerCallback_userStateChangedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userStateChanged(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userStateChanged(const ::Murmur::User& state, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerCallback_userStateChangedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userStateChanged(state, &__ctx, __del, __cookie);
    }

    void end_userStateChanged(const ::Ice::AsyncResultPtr&);
    
private:

    void userStateChanged(const ::Murmur::User&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_userStateChanged(const ::Murmur::User&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void channelCreated(const ::Murmur::Channel& state)
    {
        channelCreated(state, 0);
    }
    void channelCreated(const ::Murmur::Channel& state, const ::Ice::Context& __ctx)
    {
        channelCreated(state, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_channelCreated(const ::Murmur::Channel& state)
    {
        return begin_channelCreated(state, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_channelCreated(const ::Murmur::Channel& state, const ::Ice::Context& __ctx)
    {
        return begin_channelCreated(state, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_channelCreated(const ::Murmur::Channel& state, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_channelCreated(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_channelCreated(const ::Murmur::Channel& state, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_channelCreated(state, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_channelCreated(const ::Murmur::Channel& state, const ::Murmur::Callback_ServerCallback_channelCreatedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_channelCreated(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_channelCreated(const ::Murmur::Channel& state, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerCallback_channelCreatedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_channelCreated(state, &__ctx, __del, __cookie);
    }

    void end_channelCreated(const ::Ice::AsyncResultPtr&);
    
private:

    void channelCreated(const ::Murmur::Channel&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_channelCreated(const ::Murmur::Channel&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void channelRemoved(const ::Murmur::Channel& state)
    {
        channelRemoved(state, 0);
    }
    void channelRemoved(const ::Murmur::Channel& state, const ::Ice::Context& __ctx)
    {
        channelRemoved(state, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_channelRemoved(const ::Murmur::Channel& state)
    {
        return begin_channelRemoved(state, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_channelRemoved(const ::Murmur::Channel& state, const ::Ice::Context& __ctx)
    {
        return begin_channelRemoved(state, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_channelRemoved(const ::Murmur::Channel& state, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_channelRemoved(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_channelRemoved(const ::Murmur::Channel& state, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_channelRemoved(state, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_channelRemoved(const ::Murmur::Channel& state, const ::Murmur::Callback_ServerCallback_channelRemovedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_channelRemoved(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_channelRemoved(const ::Murmur::Channel& state, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerCallback_channelRemovedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_channelRemoved(state, &__ctx, __del, __cookie);
    }

    void end_channelRemoved(const ::Ice::AsyncResultPtr&);
    
private:

    void channelRemoved(const ::Murmur::Channel&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_channelRemoved(const ::Murmur::Channel&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void channelStateChanged(const ::Murmur::Channel& state)
    {
        channelStateChanged(state, 0);
    }
    void channelStateChanged(const ::Murmur::Channel& state, const ::Ice::Context& __ctx)
    {
        channelStateChanged(state, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_channelStateChanged(const ::Murmur::Channel& state)
    {
        return begin_channelStateChanged(state, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_channelStateChanged(const ::Murmur::Channel& state, const ::Ice::Context& __ctx)
    {
        return begin_channelStateChanged(state, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_channelStateChanged(const ::Murmur::Channel& state, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_channelStateChanged(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_channelStateChanged(const ::Murmur::Channel& state, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_channelStateChanged(state, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_channelStateChanged(const ::Murmur::Channel& state, const ::Murmur::Callback_ServerCallback_channelStateChangedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_channelStateChanged(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_channelStateChanged(const ::Murmur::Channel& state, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerCallback_channelStateChangedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_channelStateChanged(state, &__ctx, __del, __cookie);
    }

    void end_channelStateChanged(const ::Ice::AsyncResultPtr&);
    
private:

    void channelStateChanged(const ::Murmur::Channel&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_channelStateChanged(const ::Murmur::Channel&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerCallback> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerCallback*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<ServerCallback*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ServerContextCallback : virtual public ::IceProxy::Ice::Object
{
public:

    void contextAction(const ::std::string& action, const ::Murmur::User& usr, ::Ice::Int session, ::Ice::Int channelid)
    {
        contextAction(action, usr, session, channelid, 0);
    }
    void contextAction(const ::std::string& action, const ::Murmur::User& usr, ::Ice::Int session, ::Ice::Int channelid, const ::Ice::Context& __ctx)
    {
        contextAction(action, usr, session, channelid, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_contextAction(const ::std::string& action, const ::Murmur::User& usr, ::Ice::Int session, ::Ice::Int channelid)
    {
        return begin_contextAction(action, usr, session, channelid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_contextAction(const ::std::string& action, const ::Murmur::User& usr, ::Ice::Int session, ::Ice::Int channelid, const ::Ice::Context& __ctx)
    {
        return begin_contextAction(action, usr, session, channelid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_contextAction(const ::std::string& action, const ::Murmur::User& usr, ::Ice::Int session, ::Ice::Int channelid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_contextAction(action, usr, session, channelid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_contextAction(const ::std::string& action, const ::Murmur::User& usr, ::Ice::Int session, ::Ice::Int channelid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_contextAction(action, usr, session, channelid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_contextAction(const ::std::string& action, const ::Murmur::User& usr, ::Ice::Int session, ::Ice::Int channelid, const ::Murmur::Callback_ServerContextCallback_contextActionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_contextAction(action, usr, session, channelid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_contextAction(const ::std::string& action, const ::Murmur::User& usr, ::Ice::Int session, ::Ice::Int channelid, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerContextCallback_contextActionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_contextAction(action, usr, session, channelid, &__ctx, __del, __cookie);
    }

    void end_contextAction(const ::Ice::AsyncResultPtr&);
    
private:

    void contextAction(const ::std::string&, const ::Murmur::User&, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_contextAction(const ::std::string&, const ::Murmur::User&, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerContextCallback> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerContextCallback*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<ServerContextCallback*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ServerAuthenticator : virtual public ::IceProxy::Ice::Object
{
public:

    ::Ice::Int authenticate(const ::std::string& name, const ::std::string& pw, const ::Murmur::CertificateList& certificates, const ::std::string& certhash, bool certstrong, ::std::string& newname, ::Murmur::GroupNameList& groups)
    {
        return authenticate(name, pw, certificates, certhash, certstrong, newname, groups, 0);
    }
    ::Ice::Int authenticate(const ::std::string& name, const ::std::string& pw, const ::Murmur::CertificateList& certificates, const ::std::string& certhash, bool certstrong, ::std::string& newname, ::Murmur::GroupNameList& groups, const ::Ice::Context& __ctx)
    {
        return authenticate(name, pw, certificates, certhash, certstrong, newname, groups, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_authenticate(const ::std::string& name, const ::std::string& pw, const ::Murmur::CertificateList& certificates, const ::std::string& certhash, bool certstrong)
    {
        return begin_authenticate(name, pw, certificates, certhash, certstrong, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_authenticate(const ::std::string& name, const ::std::string& pw, const ::Murmur::CertificateList& certificates, const ::std::string& certhash, bool certstrong, const ::Ice::Context& __ctx)
    {
        return begin_authenticate(name, pw, certificates, certhash, certstrong, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_authenticate(const ::std::string& name, const ::std::string& pw, const ::Murmur::CertificateList& certificates, const ::std::string& certhash, bool certstrong, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_authenticate(name, pw, certificates, certhash, certstrong, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_authenticate(const ::std::string& name, const ::std::string& pw, const ::Murmur::CertificateList& certificates, const ::std::string& certhash, bool certstrong, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_authenticate(name, pw, certificates, certhash, certstrong, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_authenticate(const ::std::string& name, const ::std::string& pw, const ::Murmur::CertificateList& certificates, const ::std::string& certhash, bool certstrong, const ::Murmur::Callback_ServerAuthenticator_authenticatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_authenticate(name, pw, certificates, certhash, certstrong, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_authenticate(const ::std::string& name, const ::std::string& pw, const ::Murmur::CertificateList& certificates, const ::std::string& certhash, bool certstrong, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerAuthenticator_authenticatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_authenticate(name, pw, certificates, certhash, certstrong, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_authenticate(::std::string& newname, ::Murmur::GroupNameList& groups, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int authenticate(const ::std::string&, const ::std::string&, const ::Murmur::CertificateList&, const ::std::string&, bool, ::std::string&, ::Murmur::GroupNameList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_authenticate(const ::std::string&, const ::std::string&, const ::Murmur::CertificateList&, const ::std::string&, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getInfo(::Ice::Int id, ::Murmur::UserInfoMap& info)
    {
        return getInfo(id, info, 0);
    }
    bool getInfo(::Ice::Int id, ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx)
    {
        return getInfo(id, info, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getInfo(::Ice::Int id)
    {
        return begin_getInfo(id, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInfo(::Ice::Int id, const ::Ice::Context& __ctx)
    {
        return begin_getInfo(id, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInfo(::Ice::Int id, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInfo(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInfo(::Ice::Int id, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInfo(id, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInfo(::Ice::Int id, const ::Murmur::Callback_ServerAuthenticator_getInfoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInfo(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInfo(::Ice::Int id, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerAuthenticator_getInfoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInfo(id, &__ctx, __del, __cookie);
    }

    bool end_getInfo(::Murmur::UserInfoMap& info, const ::Ice::AsyncResultPtr&);
    
private:

    bool getInfo(::Ice::Int, ::Murmur::UserInfoMap&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getInfo(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int nameToId(const ::std::string& name)
    {
        return nameToId(name, 0);
    }
    ::Ice::Int nameToId(const ::std::string& name, const ::Ice::Context& __ctx)
    {
        return nameToId(name, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_nameToId(const ::std::string& name)
    {
        return begin_nameToId(name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_nameToId(const ::std::string& name, const ::Ice::Context& __ctx)
    {
        return begin_nameToId(name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_nameToId(const ::std::string& name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_nameToId(name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_nameToId(const ::std::string& name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_nameToId(name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_nameToId(const ::std::string& name, const ::Murmur::Callback_ServerAuthenticator_nameToIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_nameToId(name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_nameToId(const ::std::string& name, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerAuthenticator_nameToIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_nameToId(name, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_nameToId(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int nameToId(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_nameToId(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string idToName(::Ice::Int id)
    {
        return idToName(id, 0);
    }
    ::std::string idToName(::Ice::Int id, const ::Ice::Context& __ctx)
    {
        return idToName(id, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_idToName(::Ice::Int id)
    {
        return begin_idToName(id, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_idToName(::Ice::Int id, const ::Ice::Context& __ctx)
    {
        return begin_idToName(id, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_idToName(::Ice::Int id, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_idToName(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_idToName(::Ice::Int id, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_idToName(id, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_idToName(::Ice::Int id, const ::Murmur::Callback_ServerAuthenticator_idToNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_idToName(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_idToName(::Ice::Int id, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerAuthenticator_idToNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_idToName(id, &__ctx, __del, __cookie);
    }

    ::std::string end_idToName(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string idToName(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_idToName(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::Texture idToTexture(::Ice::Int id)
    {
        return idToTexture(id, 0);
    }
    ::Murmur::Texture idToTexture(::Ice::Int id, const ::Ice::Context& __ctx)
    {
        return idToTexture(id, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_idToTexture(::Ice::Int id)
    {
        return begin_idToTexture(id, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_idToTexture(::Ice::Int id, const ::Ice::Context& __ctx)
    {
        return begin_idToTexture(id, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_idToTexture(::Ice::Int id, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_idToTexture(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_idToTexture(::Ice::Int id, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_idToTexture(id, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_idToTexture(::Ice::Int id, const ::Murmur::Callback_ServerAuthenticator_idToTexturePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_idToTexture(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_idToTexture(::Ice::Int id, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerAuthenticator_idToTexturePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_idToTexture(id, &__ctx, __del, __cookie);
    }

    ::Murmur::Texture end_idToTexture(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::Texture idToTexture(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_idToTexture(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerAuthenticator> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerAuthenticator*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<ServerAuthenticator*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ServerUpdatingAuthenticator : virtual public ::IceProxy::Murmur::ServerAuthenticator
{
public:

    ::Ice::Int registerUser(const ::Murmur::UserInfoMap& info)
    {
        return registerUser(info, 0);
    }
    ::Ice::Int registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx)
    {
        return registerUser(info, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::Murmur::UserInfoMap& info)
    {
        return begin_registerUser(info, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx)
    {
        return begin_registerUser(info, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(info, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(info, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::Murmur::UserInfoMap& info, const ::Murmur::Callback_ServerUpdatingAuthenticator_registerUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(info, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerUpdatingAuthenticator_registerUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(info, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_registerUser(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int registerUser(const ::Murmur::UserInfoMap&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_registerUser(const ::Murmur::UserInfoMap&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int unregisterUser(::Ice::Int id)
    {
        return unregisterUser(id, 0);
    }
    ::Ice::Int unregisterUser(::Ice::Int id, const ::Ice::Context& __ctx)
    {
        return unregisterUser(id, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(::Ice::Int id)
    {
        return begin_unregisterUser(id, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(::Ice::Int id, const ::Ice::Context& __ctx)
    {
        return begin_unregisterUser(id, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(::Ice::Int id, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unregisterUser(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(::Ice::Int id, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unregisterUser(id, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(::Ice::Int id, const ::Murmur::Callback_ServerUpdatingAuthenticator_unregisterUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unregisterUser(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(::Ice::Int id, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerUpdatingAuthenticator_unregisterUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unregisterUser(id, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_unregisterUser(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int unregisterUser(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_unregisterUser(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::NameMap getRegisteredUsers(const ::std::string& filter)
    {
        return getRegisteredUsers(filter, 0);
    }
    ::Murmur::NameMap getRegisteredUsers(const ::std::string& filter, const ::Ice::Context& __ctx)
    {
        return getRegisteredUsers(filter, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getRegisteredUsers(const ::std::string& filter)
    {
        return begin_getRegisteredUsers(filter, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRegisteredUsers(const ::std::string& filter, const ::Ice::Context& __ctx)
    {
        return begin_getRegisteredUsers(filter, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRegisteredUsers(const ::std::string& filter, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegisteredUsers(filter, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRegisteredUsers(const ::std::string& filter, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegisteredUsers(filter, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRegisteredUsers(const ::std::string& filter, const ::Murmur::Callback_ServerUpdatingAuthenticator_getRegisteredUsersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegisteredUsers(filter, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRegisteredUsers(const ::std::string& filter, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerUpdatingAuthenticator_getRegisteredUsersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegisteredUsers(filter, &__ctx, __del, __cookie);
    }

    ::Murmur::NameMap end_getRegisteredUsers(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::NameMap getRegisteredUsers(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRegisteredUsers(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int setInfo(::Ice::Int id, const ::Murmur::UserInfoMap& info)
    {
        return setInfo(id, info, 0);
    }
    ::Ice::Int setInfo(::Ice::Int id, const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx)
    {
        return setInfo(id, info, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setInfo(::Ice::Int id, const ::Murmur::UserInfoMap& info)
    {
        return begin_setInfo(id, info, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setInfo(::Ice::Int id, const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx)
    {
        return begin_setInfo(id, info, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setInfo(::Ice::Int id, const ::Murmur::UserInfoMap& info, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInfo(id, info, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setInfo(::Ice::Int id, const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInfo(id, info, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setInfo(::Ice::Int id, const ::Murmur::UserInfoMap& info, const ::Murmur::Callback_ServerUpdatingAuthenticator_setInfoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInfo(id, info, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setInfo(::Ice::Int id, const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerUpdatingAuthenticator_setInfoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInfo(id, info, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_setInfo(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int setInfo(::Ice::Int, const ::Murmur::UserInfoMap&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setInfo(::Ice::Int, const ::Murmur::UserInfoMap&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int setTexture(::Ice::Int id, const ::Murmur::Texture& tex)
    {
        return setTexture(id, tex, 0);
    }
    ::Ice::Int setTexture(::Ice::Int id, const ::Murmur::Texture& tex, const ::Ice::Context& __ctx)
    {
        return setTexture(id, tex, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setTexture(::Ice::Int id, const ::Murmur::Texture& tex)
    {
        return begin_setTexture(id, tex, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTexture(::Ice::Int id, const ::Murmur::Texture& tex, const ::Ice::Context& __ctx)
    {
        return begin_setTexture(id, tex, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTexture(::Ice::Int id, const ::Murmur::Texture& tex, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTexture(id, tex, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTexture(::Ice::Int id, const ::Murmur::Texture& tex, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTexture(id, tex, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTexture(::Ice::Int id, const ::Murmur::Texture& tex, const ::Murmur::Callback_ServerUpdatingAuthenticator_setTexturePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTexture(id, tex, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTexture(::Ice::Int id, const ::Murmur::Texture& tex, const ::Ice::Context& __ctx, const ::Murmur::Callback_ServerUpdatingAuthenticator_setTexturePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTexture(id, tex, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_setTexture(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int setTexture(::Ice::Int, const ::Murmur::Texture&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setTexture(::Ice::Int, const ::Murmur::Texture&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerUpdatingAuthenticator> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerUpdatingAuthenticator*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<ServerUpdatingAuthenticator*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Server : virtual public ::IceProxy::Ice::Object
{
public:

    bool isRunning()
    {
        return isRunning(0);
    }
    bool isRunning(const ::Ice::Context& __ctx)
    {
        return isRunning(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_isRunning()
    {
        return begin_isRunning(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isRunning(const ::Ice::Context& __ctx)
    {
        return begin_isRunning(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isRunning(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isRunning(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isRunning(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isRunning(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isRunning(const ::Murmur::Callback_Server_isRunningPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isRunning(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isRunning(const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_isRunningPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isRunning(&__ctx, __del, __cookie);
    }

    bool end_isRunning(const ::Ice::AsyncResultPtr&);
    
private:

    bool isRunning(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_isRunning(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void start()
    {
        start(0);
    }
    void start(const ::Ice::Context& __ctx)
    {
        start(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_start()
    {
        return begin_start(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_start(const ::Ice::Context& __ctx)
    {
        return begin_start(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_start(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_start(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_start(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_start(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_start(const ::Murmur::Callback_Server_startPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_start(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_start(const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_startPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_start(&__ctx, __del, __cookie);
    }

    void end_start(const ::Ice::AsyncResultPtr&);
    
private:

    void start(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_start(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void stop()
    {
        stop(0);
    }
    void stop(const ::Ice::Context& __ctx)
    {
        stop(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_stop()
    {
        return begin_stop(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_stop(const ::Ice::Context& __ctx)
    {
        return begin_stop(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_stop(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_stop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_stop(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_stop(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_stop(const ::Murmur::Callback_Server_stopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_stop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_stop(const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_stopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_stop(&__ctx, __del, __cookie);
    }

    void end_stop(const ::Ice::AsyncResultPtr&);
    
private:

    void stop(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_stop(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void _cpp_delete()
    {
        _cpp_delete(0);
    }
    void _cpp_delete(const ::Ice::Context& __ctx)
    {
        _cpp_delete(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_delete()
    {
        return begin_delete(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_delete(const ::Ice::Context& __ctx)
    {
        return begin_delete(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_delete(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_delete(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_delete(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_delete(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_delete(const ::Murmur::Callback_Server_deletePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_delete(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_delete(const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_deletePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_delete(&__ctx, __del, __cookie);
    }

    void end_delete(const ::Ice::AsyncResultPtr&);
    
private:

    void _cpp_delete(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_delete(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int id()
    {
        return id(0);
    }
    ::Ice::Int id(const ::Ice::Context& __ctx)
    {
        return id(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_id()
    {
        return begin_id(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_id(const ::Ice::Context& __ctx)
    {
        return begin_id(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_id(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_id(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_id(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_id(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_id(const ::Murmur::Callback_Server_idPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_id(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_id(const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_idPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_id(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_id(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int id(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_id(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addCallback(const ::Murmur::ServerCallbackPrx& cb)
    {
        addCallback(cb, 0);
    }
    void addCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::Context& __ctx)
    {
        addCallback(cb, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addCallback(const ::Murmur::ServerCallbackPrx& cb)
    {
        return begin_addCallback(cb, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::Context& __ctx)
    {
        return begin_addCallback(cb, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addCallback(cb, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addCallback(cb, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Murmur::Callback_Server_addCallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addCallback(cb, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_addCallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addCallback(cb, &__ctx, __del, __cookie);
    }

    void end_addCallback(const ::Ice::AsyncResultPtr&);
    
private:

    void addCallback(const ::Murmur::ServerCallbackPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addCallback(const ::Murmur::ServerCallbackPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeCallback(const ::Murmur::ServerCallbackPrx& cb)
    {
        removeCallback(cb, 0);
    }
    void removeCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::Context& __ctx)
    {
        removeCallback(cb, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeCallback(const ::Murmur::ServerCallbackPrx& cb)
    {
        return begin_removeCallback(cb, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::Context& __ctx)
    {
        return begin_removeCallback(cb, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeCallback(cb, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeCallback(cb, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Murmur::Callback_Server_removeCallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeCallback(cb, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeCallback(const ::Murmur::ServerCallbackPrx& cb, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_removeCallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeCallback(cb, &__ctx, __del, __cookie);
    }

    void end_removeCallback(const ::Ice::AsyncResultPtr&);
    
private:

    void removeCallback(const ::Murmur::ServerCallbackPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeCallback(const ::Murmur::ServerCallbackPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setAuthenticator(const ::Murmur::ServerAuthenticatorPrx& auth)
    {
        setAuthenticator(auth, 0);
    }
    void setAuthenticator(const ::Murmur::ServerAuthenticatorPrx& auth, const ::Ice::Context& __ctx)
    {
        setAuthenticator(auth, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAuthenticator(const ::Murmur::ServerAuthenticatorPrx& auth)
    {
        return begin_setAuthenticator(auth, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAuthenticator(const ::Murmur::ServerAuthenticatorPrx& auth, const ::Ice::Context& __ctx)
    {
        return begin_setAuthenticator(auth, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAuthenticator(const ::Murmur::ServerAuthenticatorPrx& auth, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAuthenticator(auth, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAuthenticator(const ::Murmur::ServerAuthenticatorPrx& auth, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAuthenticator(auth, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAuthenticator(const ::Murmur::ServerAuthenticatorPrx& auth, const ::Murmur::Callback_Server_setAuthenticatorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAuthenticator(auth, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAuthenticator(const ::Murmur::ServerAuthenticatorPrx& auth, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_setAuthenticatorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAuthenticator(auth, &__ctx, __del, __cookie);
    }

    void end_setAuthenticator(const ::Ice::AsyncResultPtr&);
    
private:

    void setAuthenticator(const ::Murmur::ServerAuthenticatorPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAuthenticator(const ::Murmur::ServerAuthenticatorPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getConf(const ::std::string& key)
    {
        return getConf(key, 0);
    }
    ::std::string getConf(const ::std::string& key, const ::Ice::Context& __ctx)
    {
        return getConf(key, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getConf(const ::std::string& key)
    {
        return begin_getConf(key, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getConf(const ::std::string& key, const ::Ice::Context& __ctx)
    {
        return begin_getConf(key, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getConf(const ::std::string& key, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConf(key, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConf(const ::std::string& key, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConf(key, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConf(const ::std::string& key, const ::Murmur::Callback_Server_getConfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConf(key, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConf(const ::std::string& key, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getConfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConf(key, &__ctx, __del, __cookie);
    }

    ::std::string end_getConf(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getConf(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getConf(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::ConfigMap getAllConf()
    {
        return getAllConf(0);
    }
    ::Murmur::ConfigMap getAllConf(const ::Ice::Context& __ctx)
    {
        return getAllConf(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAllConf()
    {
        return begin_getAllConf(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAllConf(const ::Ice::Context& __ctx)
    {
        return begin_getAllConf(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAllConf(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllConf(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllConf(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllConf(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllConf(const ::Murmur::Callback_Server_getAllConfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllConf(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllConf(const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getAllConfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllConf(&__ctx, __del, __cookie);
    }

    ::Murmur::ConfigMap end_getAllConf(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::ConfigMap getAllConf(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAllConf(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setConf(const ::std::string& key, const ::std::string& value)
    {
        setConf(key, value, 0);
    }
    void setConf(const ::std::string& key, const ::std::string& value, const ::Ice::Context& __ctx)
    {
        setConf(key, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setConf(const ::std::string& key, const ::std::string& value)
    {
        return begin_setConf(key, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setConf(const ::std::string& key, const ::std::string& value, const ::Ice::Context& __ctx)
    {
        return begin_setConf(key, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setConf(const ::std::string& key, const ::std::string& value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setConf(key, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setConf(const ::std::string& key, const ::std::string& value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setConf(key, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setConf(const ::std::string& key, const ::std::string& value, const ::Murmur::Callback_Server_setConfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setConf(key, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setConf(const ::std::string& key, const ::std::string& value, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_setConfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setConf(key, value, &__ctx, __del, __cookie);
    }

    void end_setConf(const ::Ice::AsyncResultPtr&);
    
private:

    void setConf(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setConf(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setSuperuserPassword(const ::std::string& pw)
    {
        setSuperuserPassword(pw, 0);
    }
    void setSuperuserPassword(const ::std::string& pw, const ::Ice::Context& __ctx)
    {
        setSuperuserPassword(pw, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setSuperuserPassword(const ::std::string& pw)
    {
        return begin_setSuperuserPassword(pw, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSuperuserPassword(const ::std::string& pw, const ::Ice::Context& __ctx)
    {
        return begin_setSuperuserPassword(pw, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSuperuserPassword(const ::std::string& pw, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSuperuserPassword(pw, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSuperuserPassword(const ::std::string& pw, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSuperuserPassword(pw, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSuperuserPassword(const ::std::string& pw, const ::Murmur::Callback_Server_setSuperuserPasswordPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSuperuserPassword(pw, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSuperuserPassword(const ::std::string& pw, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_setSuperuserPasswordPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSuperuserPassword(pw, &__ctx, __del, __cookie);
    }

    void end_setSuperuserPassword(const ::Ice::AsyncResultPtr&);
    
private:

    void setSuperuserPassword(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setSuperuserPassword(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::LogList getLog(::Ice::Int first, ::Ice::Int last)
    {
        return getLog(first, last, 0);
    }
    ::Murmur::LogList getLog(::Ice::Int first, ::Ice::Int last, const ::Ice::Context& __ctx)
    {
        return getLog(first, last, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getLog(::Ice::Int first, ::Ice::Int last)
    {
        return begin_getLog(first, last, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLog(::Ice::Int first, ::Ice::Int last, const ::Ice::Context& __ctx)
    {
        return begin_getLog(first, last, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLog(::Ice::Int first, ::Ice::Int last, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLog(first, last, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLog(::Ice::Int first, ::Ice::Int last, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLog(first, last, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLog(::Ice::Int first, ::Ice::Int last, const ::Murmur::Callback_Server_getLogPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLog(first, last, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLog(::Ice::Int first, ::Ice::Int last, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getLogPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLog(first, last, &__ctx, __del, __cookie);
    }

    ::Murmur::LogList end_getLog(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::LogList getLog(::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getLog(::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getLogLen()
    {
        return getLogLen(0);
    }
    ::Ice::Int getLogLen(const ::Ice::Context& __ctx)
    {
        return getLogLen(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getLogLen()
    {
        return begin_getLogLen(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLogLen(const ::Ice::Context& __ctx)
    {
        return begin_getLogLen(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLogLen(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogLen(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLogLen(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogLen(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLogLen(const ::Murmur::Callback_Server_getLogLenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogLen(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLogLen(const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getLogLenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogLen(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_getLogLen(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getLogLen(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getLogLen(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::UserMap getUsers()
    {
        return getUsers(0);
    }
    ::Murmur::UserMap getUsers(const ::Ice::Context& __ctx)
    {
        return getUsers(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getUsers()
    {
        return begin_getUsers(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUsers(const ::Ice::Context& __ctx)
    {
        return begin_getUsers(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUsers(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsers(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsers(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsers(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsers(const ::Murmur::Callback_Server_getUsersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsers(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsers(const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getUsersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsers(&__ctx, __del, __cookie);
    }

    ::Murmur::UserMap end_getUsers(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::UserMap getUsers(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUsers(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::ChannelMap getChannels()
    {
        return getChannels(0);
    }
    ::Murmur::ChannelMap getChannels(const ::Ice::Context& __ctx)
    {
        return getChannels(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getChannels()
    {
        return begin_getChannels(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getChannels(const ::Ice::Context& __ctx)
    {
        return begin_getChannels(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getChannels(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getChannels(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getChannels(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getChannels(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getChannels(const ::Murmur::Callback_Server_getChannelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getChannels(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getChannels(const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getChannelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getChannels(&__ctx, __del, __cookie);
    }

    ::Murmur::ChannelMap end_getChannels(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::ChannelMap getChannels(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getChannels(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::CertificateList getCertificateList(::Ice::Int session)
    {
        return getCertificateList(session, 0);
    }
    ::Murmur::CertificateList getCertificateList(::Ice::Int session, const ::Ice::Context& __ctx)
    {
        return getCertificateList(session, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getCertificateList(::Ice::Int session)
    {
        return begin_getCertificateList(session, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getCertificateList(::Ice::Int session, const ::Ice::Context& __ctx)
    {
        return begin_getCertificateList(session, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getCertificateList(::Ice::Int session, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCertificateList(session, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCertificateList(::Ice::Int session, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCertificateList(session, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCertificateList(::Ice::Int session, const ::Murmur::Callback_Server_getCertificateListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCertificateList(session, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCertificateList(::Ice::Int session, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getCertificateListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCertificateList(session, &__ctx, __del, __cookie);
    }

    ::Murmur::CertificateList end_getCertificateList(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::CertificateList getCertificateList(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getCertificateList(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::TreePtr getTree()
    {
        return getTree(0);
    }
    ::Murmur::TreePtr getTree(const ::Ice::Context& __ctx)
    {
        return getTree(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getTree()
    {
        return begin_getTree(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTree(const ::Ice::Context& __ctx)
    {
        return begin_getTree(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTree(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTree(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTree(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTree(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTree(const ::Murmur::Callback_Server_getTreePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTree(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTree(const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getTreePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTree(&__ctx, __del, __cookie);
    }

    ::Murmur::TreePtr end_getTree(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::TreePtr getTree(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTree(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::BanList getBans()
    {
        return getBans(0);
    }
    ::Murmur::BanList getBans(const ::Ice::Context& __ctx)
    {
        return getBans(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getBans()
    {
        return begin_getBans(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getBans(const ::Ice::Context& __ctx)
    {
        return begin_getBans(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getBans(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBans(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBans(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBans(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBans(const ::Murmur::Callback_Server_getBansPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBans(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBans(const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getBansPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBans(&__ctx, __del, __cookie);
    }

    ::Murmur::BanList end_getBans(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::BanList getBans(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getBans(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setBans(const ::Murmur::BanList& bans)
    {
        setBans(bans, 0);
    }
    void setBans(const ::Murmur::BanList& bans, const ::Ice::Context& __ctx)
    {
        setBans(bans, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setBans(const ::Murmur::BanList& bans)
    {
        return begin_setBans(bans, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setBans(const ::Murmur::BanList& bans, const ::Ice::Context& __ctx)
    {
        return begin_setBans(bans, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setBans(const ::Murmur::BanList& bans, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBans(bans, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setBans(const ::Murmur::BanList& bans, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBans(bans, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setBans(const ::Murmur::BanList& bans, const ::Murmur::Callback_Server_setBansPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBans(bans, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setBans(const ::Murmur::BanList& bans, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_setBansPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBans(bans, &__ctx, __del, __cookie);
    }

    void end_setBans(const ::Ice::AsyncResultPtr&);
    
private:

    void setBans(const ::Murmur::BanList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setBans(const ::Murmur::BanList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void kickUser(::Ice::Int session, const ::std::string& reason)
    {
        kickUser(session, reason, 0);
    }
    void kickUser(::Ice::Int session, const ::std::string& reason, const ::Ice::Context& __ctx)
    {
        kickUser(session, reason, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_kickUser(::Ice::Int session, const ::std::string& reason)
    {
        return begin_kickUser(session, reason, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_kickUser(::Ice::Int session, const ::std::string& reason, const ::Ice::Context& __ctx)
    {
        return begin_kickUser(session, reason, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_kickUser(::Ice::Int session, const ::std::string& reason, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickUser(session, reason, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kickUser(::Ice::Int session, const ::std::string& reason, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickUser(session, reason, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kickUser(::Ice::Int session, const ::std::string& reason, const ::Murmur::Callback_Server_kickUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickUser(session, reason, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kickUser(::Ice::Int session, const ::std::string& reason, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_kickUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickUser(session, reason, &__ctx, __del, __cookie);
    }

    void end_kickUser(const ::Ice::AsyncResultPtr&);
    
private:

    void kickUser(::Ice::Int, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_kickUser(::Ice::Int, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::User getState(::Ice::Int session)
    {
        return getState(session, 0);
    }
    ::Murmur::User getState(::Ice::Int session, const ::Ice::Context& __ctx)
    {
        return getState(session, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getState(::Ice::Int session)
    {
        return begin_getState(session, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getState(::Ice::Int session, const ::Ice::Context& __ctx)
    {
        return begin_getState(session, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getState(::Ice::Int session, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getState(session, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getState(::Ice::Int session, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getState(session, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getState(::Ice::Int session, const ::Murmur::Callback_Server_getStatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getState(session, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getState(::Ice::Int session, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getStatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getState(session, &__ctx, __del, __cookie);
    }

    ::Murmur::User end_getState(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::User getState(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getState(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setState(const ::Murmur::User& state)
    {
        setState(state, 0);
    }
    void setState(const ::Murmur::User& state, const ::Ice::Context& __ctx)
    {
        setState(state, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setState(const ::Murmur::User& state)
    {
        return begin_setState(state, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setState(const ::Murmur::User& state, const ::Ice::Context& __ctx)
    {
        return begin_setState(state, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setState(const ::Murmur::User& state, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setState(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setState(const ::Murmur::User& state, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setState(state, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setState(const ::Murmur::User& state, const ::Murmur::Callback_Server_setStatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setState(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setState(const ::Murmur::User& state, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_setStatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setState(state, &__ctx, __del, __cookie);
    }

    void end_setState(const ::Ice::AsyncResultPtr&);
    
private:

    void setState(const ::Murmur::User&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setState(const ::Murmur::User&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void sendMessage(::Ice::Int session, const ::std::string& text)
    {
        sendMessage(session, text, 0);
    }
    void sendMessage(::Ice::Int session, const ::std::string& text, const ::Ice::Context& __ctx)
    {
        sendMessage(session, text, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(::Ice::Int session, const ::std::string& text)
    {
        return begin_sendMessage(session, text, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(::Ice::Int session, const ::std::string& text, const ::Ice::Context& __ctx)
    {
        return begin_sendMessage(session, text, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(::Ice::Int session, const ::std::string& text, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(session, text, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(::Ice::Int session, const ::std::string& text, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(session, text, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(::Ice::Int session, const ::std::string& text, const ::Murmur::Callback_Server_sendMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(session, text, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(::Ice::Int session, const ::std::string& text, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_sendMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(session, text, &__ctx, __del, __cookie);
    }

    void end_sendMessage(const ::Ice::AsyncResultPtr&);
    
private:

    void sendMessage(::Ice::Int, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sendMessage(::Ice::Int, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool hasPermission(::Ice::Int session, ::Ice::Int channelid, ::Ice::Int perm)
    {
        return hasPermission(session, channelid, perm, 0);
    }
    bool hasPermission(::Ice::Int session, ::Ice::Int channelid, ::Ice::Int perm, const ::Ice::Context& __ctx)
    {
        return hasPermission(session, channelid, perm, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_hasPermission(::Ice::Int session, ::Ice::Int channelid, ::Ice::Int perm)
    {
        return begin_hasPermission(session, channelid, perm, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_hasPermission(::Ice::Int session, ::Ice::Int channelid, ::Ice::Int perm, const ::Ice::Context& __ctx)
    {
        return begin_hasPermission(session, channelid, perm, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_hasPermission(::Ice::Int session, ::Ice::Int channelid, ::Ice::Int perm, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_hasPermission(session, channelid, perm, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_hasPermission(::Ice::Int session, ::Ice::Int channelid, ::Ice::Int perm, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_hasPermission(session, channelid, perm, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_hasPermission(::Ice::Int session, ::Ice::Int channelid, ::Ice::Int perm, const ::Murmur::Callback_Server_hasPermissionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_hasPermission(session, channelid, perm, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_hasPermission(::Ice::Int session, ::Ice::Int channelid, ::Ice::Int perm, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_hasPermissionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_hasPermission(session, channelid, perm, &__ctx, __del, __cookie);
    }

    bool end_hasPermission(const ::Ice::AsyncResultPtr&);
    
private:

    bool hasPermission(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_hasPermission(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addContextCallback(::Ice::Int session, const ::std::string& action, const ::std::string& text, const ::Murmur::ServerContextCallbackPrx& cb, ::Ice::Int ctx)
    {
        addContextCallback(session, action, text, cb, ctx, 0);
    }
    void addContextCallback(::Ice::Int session, const ::std::string& action, const ::std::string& text, const ::Murmur::ServerContextCallbackPrx& cb, ::Ice::Int ctx, const ::Ice::Context& __ctx)
    {
        addContextCallback(session, action, text, cb, ctx, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addContextCallback(::Ice::Int session, const ::std::string& action, const ::std::string& text, const ::Murmur::ServerContextCallbackPrx& cb, ::Ice::Int ctx)
    {
        return begin_addContextCallback(session, action, text, cb, ctx, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addContextCallback(::Ice::Int session, const ::std::string& action, const ::std::string& text, const ::Murmur::ServerContextCallbackPrx& cb, ::Ice::Int ctx, const ::Ice::Context& __ctx)
    {
        return begin_addContextCallback(session, action, text, cb, ctx, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addContextCallback(::Ice::Int session, const ::std::string& action, const ::std::string& text, const ::Murmur::ServerContextCallbackPrx& cb, ::Ice::Int ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addContextCallback(session, action, text, cb, ctx, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addContextCallback(::Ice::Int session, const ::std::string& action, const ::std::string& text, const ::Murmur::ServerContextCallbackPrx& cb, ::Ice::Int ctx, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addContextCallback(session, action, text, cb, ctx, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addContextCallback(::Ice::Int session, const ::std::string& action, const ::std::string& text, const ::Murmur::ServerContextCallbackPrx& cb, ::Ice::Int ctx, const ::Murmur::Callback_Server_addContextCallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addContextCallback(session, action, text, cb, ctx, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addContextCallback(::Ice::Int session, const ::std::string& action, const ::std::string& text, const ::Murmur::ServerContextCallbackPrx& cb, ::Ice::Int ctx, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_addContextCallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addContextCallback(session, action, text, cb, ctx, &__ctx, __del, __cookie);
    }

    void end_addContextCallback(const ::Ice::AsyncResultPtr&);
    
private:

    void addContextCallback(::Ice::Int, const ::std::string&, const ::std::string&, const ::Murmur::ServerContextCallbackPrx&, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addContextCallback(::Ice::Int, const ::std::string&, const ::std::string&, const ::Murmur::ServerContextCallbackPrx&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeContextCallback(const ::Murmur::ServerContextCallbackPrx& cb)
    {
        removeContextCallback(cb, 0);
    }
    void removeContextCallback(const ::Murmur::ServerContextCallbackPrx& cb, const ::Ice::Context& __ctx)
    {
        removeContextCallback(cb, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeContextCallback(const ::Murmur::ServerContextCallbackPrx& cb)
    {
        return begin_removeContextCallback(cb, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeContextCallback(const ::Murmur::ServerContextCallbackPrx& cb, const ::Ice::Context& __ctx)
    {
        return begin_removeContextCallback(cb, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeContextCallback(const ::Murmur::ServerContextCallbackPrx& cb, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeContextCallback(cb, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeContextCallback(const ::Murmur::ServerContextCallbackPrx& cb, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeContextCallback(cb, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeContextCallback(const ::Murmur::ServerContextCallbackPrx& cb, const ::Murmur::Callback_Server_removeContextCallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeContextCallback(cb, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeContextCallback(const ::Murmur::ServerContextCallbackPrx& cb, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_removeContextCallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeContextCallback(cb, &__ctx, __del, __cookie);
    }

    void end_removeContextCallback(const ::Ice::AsyncResultPtr&);
    
private:

    void removeContextCallback(const ::Murmur::ServerContextCallbackPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeContextCallback(const ::Murmur::ServerContextCallbackPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::Channel getChannelState(::Ice::Int channelid)
    {
        return getChannelState(channelid, 0);
    }
    ::Murmur::Channel getChannelState(::Ice::Int channelid, const ::Ice::Context& __ctx)
    {
        return getChannelState(channelid, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getChannelState(::Ice::Int channelid)
    {
        return begin_getChannelState(channelid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getChannelState(::Ice::Int channelid, const ::Ice::Context& __ctx)
    {
        return begin_getChannelState(channelid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getChannelState(::Ice::Int channelid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getChannelState(channelid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getChannelState(::Ice::Int channelid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getChannelState(channelid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getChannelState(::Ice::Int channelid, const ::Murmur::Callback_Server_getChannelStatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getChannelState(channelid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getChannelState(::Ice::Int channelid, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getChannelStatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getChannelState(channelid, &__ctx, __del, __cookie);
    }

    ::Murmur::Channel end_getChannelState(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::Channel getChannelState(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getChannelState(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setChannelState(const ::Murmur::Channel& state)
    {
        setChannelState(state, 0);
    }
    void setChannelState(const ::Murmur::Channel& state, const ::Ice::Context& __ctx)
    {
        setChannelState(state, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setChannelState(const ::Murmur::Channel& state)
    {
        return begin_setChannelState(state, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setChannelState(const ::Murmur::Channel& state, const ::Ice::Context& __ctx)
    {
        return begin_setChannelState(state, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setChannelState(const ::Murmur::Channel& state, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setChannelState(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setChannelState(const ::Murmur::Channel& state, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setChannelState(state, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setChannelState(const ::Murmur::Channel& state, const ::Murmur::Callback_Server_setChannelStatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setChannelState(state, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setChannelState(const ::Murmur::Channel& state, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_setChannelStatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setChannelState(state, &__ctx, __del, __cookie);
    }

    void end_setChannelState(const ::Ice::AsyncResultPtr&);
    
private:

    void setChannelState(const ::Murmur::Channel&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setChannelState(const ::Murmur::Channel&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeChannel(::Ice::Int channelid)
    {
        removeChannel(channelid, 0);
    }
    void removeChannel(::Ice::Int channelid, const ::Ice::Context& __ctx)
    {
        removeChannel(channelid, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeChannel(::Ice::Int channelid)
    {
        return begin_removeChannel(channelid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeChannel(::Ice::Int channelid, const ::Ice::Context& __ctx)
    {
        return begin_removeChannel(channelid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeChannel(::Ice::Int channelid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChannel(channelid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeChannel(::Ice::Int channelid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChannel(channelid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeChannel(::Ice::Int channelid, const ::Murmur::Callback_Server_removeChannelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChannel(channelid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeChannel(::Ice::Int channelid, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_removeChannelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChannel(channelid, &__ctx, __del, __cookie);
    }

    void end_removeChannel(const ::Ice::AsyncResultPtr&);
    
private:

    void removeChannel(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeChannel(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int addChannel(const ::std::string& name, ::Ice::Int parent)
    {
        return addChannel(name, parent, 0);
    }
    ::Ice::Int addChannel(const ::std::string& name, ::Ice::Int parent, const ::Ice::Context& __ctx)
    {
        return addChannel(name, parent, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addChannel(const ::std::string& name, ::Ice::Int parent)
    {
        return begin_addChannel(name, parent, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addChannel(const ::std::string& name, ::Ice::Int parent, const ::Ice::Context& __ctx)
    {
        return begin_addChannel(name, parent, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addChannel(const ::std::string& name, ::Ice::Int parent, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChannel(name, parent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addChannel(const ::std::string& name, ::Ice::Int parent, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChannel(name, parent, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addChannel(const ::std::string& name, ::Ice::Int parent, const ::Murmur::Callback_Server_addChannelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChannel(name, parent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addChannel(const ::std::string& name, ::Ice::Int parent, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_addChannelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChannel(name, parent, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_addChannel(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int addChannel(const ::std::string&, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addChannel(const ::std::string&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void sendMessageChannel(::Ice::Int channelid, bool tree, const ::std::string& text)
    {
        sendMessageChannel(channelid, tree, text, 0);
    }
    void sendMessageChannel(::Ice::Int channelid, bool tree, const ::std::string& text, const ::Ice::Context& __ctx)
    {
        sendMessageChannel(channelid, tree, text, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_sendMessageChannel(::Ice::Int channelid, bool tree, const ::std::string& text)
    {
        return begin_sendMessageChannel(channelid, tree, text, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendMessageChannel(::Ice::Int channelid, bool tree, const ::std::string& text, const ::Ice::Context& __ctx)
    {
        return begin_sendMessageChannel(channelid, tree, text, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendMessageChannel(::Ice::Int channelid, bool tree, const ::std::string& text, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessageChannel(channelid, tree, text, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessageChannel(::Ice::Int channelid, bool tree, const ::std::string& text, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessageChannel(channelid, tree, text, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessageChannel(::Ice::Int channelid, bool tree, const ::std::string& text, const ::Murmur::Callback_Server_sendMessageChannelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessageChannel(channelid, tree, text, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessageChannel(::Ice::Int channelid, bool tree, const ::std::string& text, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_sendMessageChannelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessageChannel(channelid, tree, text, &__ctx, __del, __cookie);
    }

    void end_sendMessageChannel(const ::Ice::AsyncResultPtr&);
    
private:

    void sendMessageChannel(::Ice::Int, bool, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sendMessageChannel(::Ice::Int, bool, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void getACL(::Ice::Int channelid, ::Murmur::ACLList& acls, ::Murmur::GroupList& groups, bool& inherit)
    {
        getACL(channelid, acls, groups, inherit, 0);
    }
    void getACL(::Ice::Int channelid, ::Murmur::ACLList& acls, ::Murmur::GroupList& groups, bool& inherit, const ::Ice::Context& __ctx)
    {
        getACL(channelid, acls, groups, inherit, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getACL(::Ice::Int channelid)
    {
        return begin_getACL(channelid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getACL(::Ice::Int channelid, const ::Ice::Context& __ctx)
    {
        return begin_getACL(channelid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getACL(::Ice::Int channelid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getACL(channelid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getACL(::Ice::Int channelid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getACL(channelid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getACL(::Ice::Int channelid, const ::Murmur::Callback_Server_getACLPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getACL(channelid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getACL(::Ice::Int channelid, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getACLPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getACL(channelid, &__ctx, __del, __cookie);
    }

    void end_getACL(::Murmur::ACLList& acls, ::Murmur::GroupList& groups, bool& inherit, const ::Ice::AsyncResultPtr&);
    
private:

    void getACL(::Ice::Int, ::Murmur::ACLList&, ::Murmur::GroupList&, bool&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getACL(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setACL(::Ice::Int channelid, const ::Murmur::ACLList& acls, const ::Murmur::GroupList& groups, bool inherit)
    {
        setACL(channelid, acls, groups, inherit, 0);
    }
    void setACL(::Ice::Int channelid, const ::Murmur::ACLList& acls, const ::Murmur::GroupList& groups, bool inherit, const ::Ice::Context& __ctx)
    {
        setACL(channelid, acls, groups, inherit, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setACL(::Ice::Int channelid, const ::Murmur::ACLList& acls, const ::Murmur::GroupList& groups, bool inherit)
    {
        return begin_setACL(channelid, acls, groups, inherit, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setACL(::Ice::Int channelid, const ::Murmur::ACLList& acls, const ::Murmur::GroupList& groups, bool inherit, const ::Ice::Context& __ctx)
    {
        return begin_setACL(channelid, acls, groups, inherit, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setACL(::Ice::Int channelid, const ::Murmur::ACLList& acls, const ::Murmur::GroupList& groups, bool inherit, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setACL(channelid, acls, groups, inherit, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setACL(::Ice::Int channelid, const ::Murmur::ACLList& acls, const ::Murmur::GroupList& groups, bool inherit, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setACL(channelid, acls, groups, inherit, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setACL(::Ice::Int channelid, const ::Murmur::ACLList& acls, const ::Murmur::GroupList& groups, bool inherit, const ::Murmur::Callback_Server_setACLPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setACL(channelid, acls, groups, inherit, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setACL(::Ice::Int channelid, const ::Murmur::ACLList& acls, const ::Murmur::GroupList& groups, bool inherit, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_setACLPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setACL(channelid, acls, groups, inherit, &__ctx, __del, __cookie);
    }

    void end_setACL(const ::Ice::AsyncResultPtr&);
    
private:

    void setACL(::Ice::Int, const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setACL(::Ice::Int, const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addUserToGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group)
    {
        addUserToGroup(channelid, session, group, 0);
    }
    void addUserToGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::Context& __ctx)
    {
        addUserToGroup(channelid, session, group, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addUserToGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group)
    {
        return begin_addUserToGroup(channelid, session, group, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addUserToGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::Context& __ctx)
    {
        return begin_addUserToGroup(channelid, session, group, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addUserToGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addUserToGroup(channelid, session, group, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addUserToGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addUserToGroup(channelid, session, group, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addUserToGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Murmur::Callback_Server_addUserToGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addUserToGroup(channelid, session, group, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addUserToGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_addUserToGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addUserToGroup(channelid, session, group, &__ctx, __del, __cookie);
    }

    void end_addUserToGroup(const ::Ice::AsyncResultPtr&);
    
private:

    void addUserToGroup(::Ice::Int, ::Ice::Int, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addUserToGroup(::Ice::Int, ::Ice::Int, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeUserFromGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group)
    {
        removeUserFromGroup(channelid, session, group, 0);
    }
    void removeUserFromGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::Context& __ctx)
    {
        removeUserFromGroup(channelid, session, group, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeUserFromGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group)
    {
        return begin_removeUserFromGroup(channelid, session, group, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeUserFromGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::Context& __ctx)
    {
        return begin_removeUserFromGroup(channelid, session, group, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeUserFromGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeUserFromGroup(channelid, session, group, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeUserFromGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeUserFromGroup(channelid, session, group, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeUserFromGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Murmur::Callback_Server_removeUserFromGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeUserFromGroup(channelid, session, group, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeUserFromGroup(::Ice::Int channelid, ::Ice::Int session, const ::std::string& group, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_removeUserFromGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeUserFromGroup(channelid, session, group, &__ctx, __del, __cookie);
    }

    void end_removeUserFromGroup(const ::Ice::AsyncResultPtr&);
    
private:

    void removeUserFromGroup(::Ice::Int, ::Ice::Int, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeUserFromGroup(::Ice::Int, ::Ice::Int, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void redirectWhisperGroup(::Ice::Int session, const ::std::string& source, const ::std::string& target)
    {
        redirectWhisperGroup(session, source, target, 0);
    }
    void redirectWhisperGroup(::Ice::Int session, const ::std::string& source, const ::std::string& target, const ::Ice::Context& __ctx)
    {
        redirectWhisperGroup(session, source, target, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_redirectWhisperGroup(::Ice::Int session, const ::std::string& source, const ::std::string& target)
    {
        return begin_redirectWhisperGroup(session, source, target, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_redirectWhisperGroup(::Ice::Int session, const ::std::string& source, const ::std::string& target, const ::Ice::Context& __ctx)
    {
        return begin_redirectWhisperGroup(session, source, target, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_redirectWhisperGroup(::Ice::Int session, const ::std::string& source, const ::std::string& target, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_redirectWhisperGroup(session, source, target, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_redirectWhisperGroup(::Ice::Int session, const ::std::string& source, const ::std::string& target, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_redirectWhisperGroup(session, source, target, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_redirectWhisperGroup(::Ice::Int session, const ::std::string& source, const ::std::string& target, const ::Murmur::Callback_Server_redirectWhisperGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_redirectWhisperGroup(session, source, target, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_redirectWhisperGroup(::Ice::Int session, const ::std::string& source, const ::std::string& target, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_redirectWhisperGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_redirectWhisperGroup(session, source, target, &__ctx, __del, __cookie);
    }

    void end_redirectWhisperGroup(const ::Ice::AsyncResultPtr&);
    
private:

    void redirectWhisperGroup(::Ice::Int, const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_redirectWhisperGroup(::Ice::Int, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::NameMap getUserNames(const ::Murmur::IdList& ids)
    {
        return getUserNames(ids, 0);
    }
    ::Murmur::NameMap getUserNames(const ::Murmur::IdList& ids, const ::Ice::Context& __ctx)
    {
        return getUserNames(ids, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getUserNames(const ::Murmur::IdList& ids)
    {
        return begin_getUserNames(ids, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUserNames(const ::Murmur::IdList& ids, const ::Ice::Context& __ctx)
    {
        return begin_getUserNames(ids, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUserNames(const ::Murmur::IdList& ids, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserNames(ids, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserNames(const ::Murmur::IdList& ids, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserNames(ids, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserNames(const ::Murmur::IdList& ids, const ::Murmur::Callback_Server_getUserNamesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserNames(ids, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserNames(const ::Murmur::IdList& ids, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getUserNamesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserNames(ids, &__ctx, __del, __cookie);
    }

    ::Murmur::NameMap end_getUserNames(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::NameMap getUserNames(const ::Murmur::IdList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUserNames(const ::Murmur::IdList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::IdMap getUserIds(const ::Murmur::NameList& names)
    {
        return getUserIds(names, 0);
    }
    ::Murmur::IdMap getUserIds(const ::Murmur::NameList& names, const ::Ice::Context& __ctx)
    {
        return getUserIds(names, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getUserIds(const ::Murmur::NameList& names)
    {
        return begin_getUserIds(names, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUserIds(const ::Murmur::NameList& names, const ::Ice::Context& __ctx)
    {
        return begin_getUserIds(names, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUserIds(const ::Murmur::NameList& names, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserIds(names, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserIds(const ::Murmur::NameList& names, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserIds(names, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserIds(const ::Murmur::NameList& names, const ::Murmur::Callback_Server_getUserIdsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserIds(names, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserIds(const ::Murmur::NameList& names, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getUserIdsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserIds(names, &__ctx, __del, __cookie);
    }

    ::Murmur::IdMap end_getUserIds(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::IdMap getUserIds(const ::Murmur::NameList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUserIds(const ::Murmur::NameList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int registerUser(const ::Murmur::UserInfoMap& info)
    {
        return registerUser(info, 0);
    }
    ::Ice::Int registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx)
    {
        return registerUser(info, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::Murmur::UserInfoMap& info)
    {
        return begin_registerUser(info, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx)
    {
        return begin_registerUser(info, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(info, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(info, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::Murmur::UserInfoMap& info, const ::Murmur::Callback_Server_registerUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(info, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_registerUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(info, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_registerUser(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int registerUser(const ::Murmur::UserInfoMap&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_registerUser(const ::Murmur::UserInfoMap&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void unregisterUser(::Ice::Int userid)
    {
        unregisterUser(userid, 0);
    }
    void unregisterUser(::Ice::Int userid, const ::Ice::Context& __ctx)
    {
        unregisterUser(userid, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(::Ice::Int userid)
    {
        return begin_unregisterUser(userid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(::Ice::Int userid, const ::Ice::Context& __ctx)
    {
        return begin_unregisterUser(userid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(::Ice::Int userid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unregisterUser(userid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(::Ice::Int userid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unregisterUser(userid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(::Ice::Int userid, const ::Murmur::Callback_Server_unregisterUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unregisterUser(userid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(::Ice::Int userid, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_unregisterUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unregisterUser(userid, &__ctx, __del, __cookie);
    }

    void end_unregisterUser(const ::Ice::AsyncResultPtr&);
    
private:

    void unregisterUser(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_unregisterUser(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void updateRegistration(::Ice::Int userid, const ::Murmur::UserInfoMap& info)
    {
        updateRegistration(userid, info, 0);
    }
    void updateRegistration(::Ice::Int userid, const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx)
    {
        updateRegistration(userid, info, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_updateRegistration(::Ice::Int userid, const ::Murmur::UserInfoMap& info)
    {
        return begin_updateRegistration(userid, info, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateRegistration(::Ice::Int userid, const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx)
    {
        return begin_updateRegistration(userid, info, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateRegistration(::Ice::Int userid, const ::Murmur::UserInfoMap& info, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateRegistration(userid, info, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateRegistration(::Ice::Int userid, const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateRegistration(userid, info, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateRegistration(::Ice::Int userid, const ::Murmur::UserInfoMap& info, const ::Murmur::Callback_Server_updateRegistrationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateRegistration(userid, info, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateRegistration(::Ice::Int userid, const ::Murmur::UserInfoMap& info, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_updateRegistrationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateRegistration(userid, info, &__ctx, __del, __cookie);
    }

    void end_updateRegistration(const ::Ice::AsyncResultPtr&);
    
private:

    void updateRegistration(::Ice::Int, const ::Murmur::UserInfoMap&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_updateRegistration(::Ice::Int, const ::Murmur::UserInfoMap&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::UserInfoMap getRegistration(::Ice::Int userid)
    {
        return getRegistration(userid, 0);
    }
    ::Murmur::UserInfoMap getRegistration(::Ice::Int userid, const ::Ice::Context& __ctx)
    {
        return getRegistration(userid, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getRegistration(::Ice::Int userid)
    {
        return begin_getRegistration(userid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRegistration(::Ice::Int userid, const ::Ice::Context& __ctx)
    {
        return begin_getRegistration(userid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRegistration(::Ice::Int userid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegistration(userid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRegistration(::Ice::Int userid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegistration(userid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRegistration(::Ice::Int userid, const ::Murmur::Callback_Server_getRegistrationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegistration(userid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRegistration(::Ice::Int userid, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getRegistrationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegistration(userid, &__ctx, __del, __cookie);
    }

    ::Murmur::UserInfoMap end_getRegistration(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::UserInfoMap getRegistration(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRegistration(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::NameMap getRegisteredUsers(const ::std::string& filter)
    {
        return getRegisteredUsers(filter, 0);
    }
    ::Murmur::NameMap getRegisteredUsers(const ::std::string& filter, const ::Ice::Context& __ctx)
    {
        return getRegisteredUsers(filter, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getRegisteredUsers(const ::std::string& filter)
    {
        return begin_getRegisteredUsers(filter, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRegisteredUsers(const ::std::string& filter, const ::Ice::Context& __ctx)
    {
        return begin_getRegisteredUsers(filter, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRegisteredUsers(const ::std::string& filter, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegisteredUsers(filter, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRegisteredUsers(const ::std::string& filter, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegisteredUsers(filter, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRegisteredUsers(const ::std::string& filter, const ::Murmur::Callback_Server_getRegisteredUsersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegisteredUsers(filter, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRegisteredUsers(const ::std::string& filter, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getRegisteredUsersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegisteredUsers(filter, &__ctx, __del, __cookie);
    }

    ::Murmur::NameMap end_getRegisteredUsers(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::NameMap getRegisteredUsers(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRegisteredUsers(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int verifyPassword(const ::std::string& name, const ::std::string& pw)
    {
        return verifyPassword(name, pw, 0);
    }
    ::Ice::Int verifyPassword(const ::std::string& name, const ::std::string& pw, const ::Ice::Context& __ctx)
    {
        return verifyPassword(name, pw, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_verifyPassword(const ::std::string& name, const ::std::string& pw)
    {
        return begin_verifyPassword(name, pw, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_verifyPassword(const ::std::string& name, const ::std::string& pw, const ::Ice::Context& __ctx)
    {
        return begin_verifyPassword(name, pw, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_verifyPassword(const ::std::string& name, const ::std::string& pw, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_verifyPassword(name, pw, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_verifyPassword(const ::std::string& name, const ::std::string& pw, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_verifyPassword(name, pw, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_verifyPassword(const ::std::string& name, const ::std::string& pw, const ::Murmur::Callback_Server_verifyPasswordPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_verifyPassword(name, pw, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_verifyPassword(const ::std::string& name, const ::std::string& pw, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_verifyPasswordPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_verifyPassword(name, pw, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_verifyPassword(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int verifyPassword(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_verifyPassword(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::Texture getTexture(::Ice::Int userid)
    {
        return getTexture(userid, 0);
    }
    ::Murmur::Texture getTexture(::Ice::Int userid, const ::Ice::Context& __ctx)
    {
        return getTexture(userid, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getTexture(::Ice::Int userid)
    {
        return begin_getTexture(userid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTexture(::Ice::Int userid, const ::Ice::Context& __ctx)
    {
        return begin_getTexture(userid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTexture(::Ice::Int userid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTexture(userid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTexture(::Ice::Int userid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTexture(userid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTexture(::Ice::Int userid, const ::Murmur::Callback_Server_getTexturePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTexture(userid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTexture(::Ice::Int userid, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getTexturePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTexture(userid, &__ctx, __del, __cookie);
    }

    ::Murmur::Texture end_getTexture(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::Texture getTexture(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTexture(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setTexture(::Ice::Int userid, const ::Murmur::Texture& tex)
    {
        setTexture(userid, tex, 0);
    }
    void setTexture(::Ice::Int userid, const ::Murmur::Texture& tex, const ::Ice::Context& __ctx)
    {
        setTexture(userid, tex, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setTexture(::Ice::Int userid, const ::Murmur::Texture& tex)
    {
        return begin_setTexture(userid, tex, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTexture(::Ice::Int userid, const ::Murmur::Texture& tex, const ::Ice::Context& __ctx)
    {
        return begin_setTexture(userid, tex, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTexture(::Ice::Int userid, const ::Murmur::Texture& tex, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTexture(userid, tex, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTexture(::Ice::Int userid, const ::Murmur::Texture& tex, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTexture(userid, tex, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTexture(::Ice::Int userid, const ::Murmur::Texture& tex, const ::Murmur::Callback_Server_setTexturePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTexture(userid, tex, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTexture(::Ice::Int userid, const ::Murmur::Texture& tex, const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_setTexturePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTexture(userid, tex, &__ctx, __del, __cookie);
    }

    void end_setTexture(const ::Ice::AsyncResultPtr&);
    
private:

    void setTexture(::Ice::Int, const ::Murmur::Texture&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setTexture(::Ice::Int, const ::Murmur::Texture&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getUptime()
    {
        return getUptime(0);
    }
    ::Ice::Int getUptime(const ::Ice::Context& __ctx)
    {
        return getUptime(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getUptime()
    {
        return begin_getUptime(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUptime(const ::Ice::Context& __ctx)
    {
        return begin_getUptime(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUptime(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUptime(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUptime(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUptime(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUptime(const ::Murmur::Callback_Server_getUptimePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUptime(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUptime(const ::Ice::Context& __ctx, const ::Murmur::Callback_Server_getUptimePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUptime(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_getUptime(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getUptime(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUptime(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<Server> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Server> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Server*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<Server*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class MetaCallback : virtual public ::IceProxy::Ice::Object
{
public:

    void started(const ::Murmur::ServerPrx& srv)
    {
        started(srv, 0);
    }
    void started(const ::Murmur::ServerPrx& srv, const ::Ice::Context& __ctx)
    {
        started(srv, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_started(const ::Murmur::ServerPrx& srv)
    {
        return begin_started(srv, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_started(const ::Murmur::ServerPrx& srv, const ::Ice::Context& __ctx)
    {
        return begin_started(srv, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_started(const ::Murmur::ServerPrx& srv, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_started(srv, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_started(const ::Murmur::ServerPrx& srv, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_started(srv, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_started(const ::Murmur::ServerPrx& srv, const ::Murmur::Callback_MetaCallback_startedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_started(srv, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_started(const ::Murmur::ServerPrx& srv, const ::Ice::Context& __ctx, const ::Murmur::Callback_MetaCallback_startedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_started(srv, &__ctx, __del, __cookie);
    }

    void end_started(const ::Ice::AsyncResultPtr&);
    
private:

    void started(const ::Murmur::ServerPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_started(const ::Murmur::ServerPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void stopped(const ::Murmur::ServerPrx& srv)
    {
        stopped(srv, 0);
    }
    void stopped(const ::Murmur::ServerPrx& srv, const ::Ice::Context& __ctx)
    {
        stopped(srv, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_stopped(const ::Murmur::ServerPrx& srv)
    {
        return begin_stopped(srv, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_stopped(const ::Murmur::ServerPrx& srv, const ::Ice::Context& __ctx)
    {
        return begin_stopped(srv, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_stopped(const ::Murmur::ServerPrx& srv, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_stopped(srv, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_stopped(const ::Murmur::ServerPrx& srv, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_stopped(srv, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_stopped(const ::Murmur::ServerPrx& srv, const ::Murmur::Callback_MetaCallback_stoppedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_stopped(srv, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_stopped(const ::Murmur::ServerPrx& srv, const ::Ice::Context& __ctx, const ::Murmur::Callback_MetaCallback_stoppedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_stopped(srv, &__ctx, __del, __cookie);
    }

    void end_stopped(const ::Ice::AsyncResultPtr&);
    
private:

    void stopped(const ::Murmur::ServerPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_stopped(const ::Murmur::ServerPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MetaCallback> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MetaCallback*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<MetaCallback*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Meta : virtual public ::IceProxy::Ice::Object
{
public:

    ::Murmur::ServerPrx getServer(::Ice::Int id)
    {
        return getServer(id, 0);
    }
    ::Murmur::ServerPrx getServer(::Ice::Int id, const ::Ice::Context& __ctx)
    {
        return getServer(id, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getServer(::Ice::Int id)
    {
        return begin_getServer(id, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getServer(::Ice::Int id, const ::Ice::Context& __ctx)
    {
        return begin_getServer(id, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getServer(::Ice::Int id, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getServer(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getServer(::Ice::Int id, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getServer(id, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getServer(::Ice::Int id, const ::Murmur::Callback_Meta_getServerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getServer(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getServer(::Ice::Int id, const ::Ice::Context& __ctx, const ::Murmur::Callback_Meta_getServerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getServer(id, &__ctx, __del, __cookie);
    }

    ::Murmur::ServerPrx end_getServer(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::ServerPrx getServer(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getServer(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::ServerPrx newServer()
    {
        return newServer(0);
    }
    ::Murmur::ServerPrx newServer(const ::Ice::Context& __ctx)
    {
        return newServer(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_newServer()
    {
        return begin_newServer(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newServer(const ::Ice::Context& __ctx)
    {
        return begin_newServer(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newServer(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newServer(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newServer(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newServer(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newServer(const ::Murmur::Callback_Meta_newServerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newServer(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newServer(const ::Ice::Context& __ctx, const ::Murmur::Callback_Meta_newServerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newServer(&__ctx, __del, __cookie);
    }

    ::Murmur::ServerPrx end_newServer(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::ServerPrx newServer(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_newServer(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::ServerList getBootedServers()
    {
        return getBootedServers(0);
    }
    ::Murmur::ServerList getBootedServers(const ::Ice::Context& __ctx)
    {
        return getBootedServers(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getBootedServers()
    {
        return begin_getBootedServers(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getBootedServers(const ::Ice::Context& __ctx)
    {
        return begin_getBootedServers(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getBootedServers(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBootedServers(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBootedServers(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBootedServers(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBootedServers(const ::Murmur::Callback_Meta_getBootedServersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBootedServers(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBootedServers(const ::Ice::Context& __ctx, const ::Murmur::Callback_Meta_getBootedServersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBootedServers(&__ctx, __del, __cookie);
    }

    ::Murmur::ServerList end_getBootedServers(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::ServerList getBootedServers(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getBootedServers(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::ServerList getAllServers()
    {
        return getAllServers(0);
    }
    ::Murmur::ServerList getAllServers(const ::Ice::Context& __ctx)
    {
        return getAllServers(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAllServers()
    {
        return begin_getAllServers(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAllServers(const ::Ice::Context& __ctx)
    {
        return begin_getAllServers(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAllServers(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllServers(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllServers(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllServers(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllServers(const ::Murmur::Callback_Meta_getAllServersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllServers(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllServers(const ::Ice::Context& __ctx, const ::Murmur::Callback_Meta_getAllServersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllServers(&__ctx, __del, __cookie);
    }

    ::Murmur::ServerList end_getAllServers(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::ServerList getAllServers(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAllServers(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Murmur::ConfigMap getDefaultConf()
    {
        return getDefaultConf(0);
    }
    ::Murmur::ConfigMap getDefaultConf(const ::Ice::Context& __ctx)
    {
        return getDefaultConf(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getDefaultConf()
    {
        return begin_getDefaultConf(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDefaultConf(const ::Ice::Context& __ctx)
    {
        return begin_getDefaultConf(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDefaultConf(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDefaultConf(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDefaultConf(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDefaultConf(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDefaultConf(const ::Murmur::Callback_Meta_getDefaultConfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDefaultConf(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDefaultConf(const ::Ice::Context& __ctx, const ::Murmur::Callback_Meta_getDefaultConfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDefaultConf(&__ctx, __del, __cookie);
    }

    ::Murmur::ConfigMap end_getDefaultConf(const ::Ice::AsyncResultPtr&);
    
private:

    ::Murmur::ConfigMap getDefaultConf(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getDefaultConf(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void getVersion(::Ice::Int& major, ::Ice::Int& minor, ::Ice::Int& patch, ::std::string& text)
    {
        getVersion(major, minor, patch, text, 0);
    }
    void getVersion(::Ice::Int& major, ::Ice::Int& minor, ::Ice::Int& patch, ::std::string& text, const ::Ice::Context& __ctx)
    {
        getVersion(major, minor, patch, text, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getVersion()
    {
        return begin_getVersion(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx)
    {
        return begin_getVersion(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Murmur::Callback_Meta_getVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx, const ::Murmur::Callback_Meta_getVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(&__ctx, __del, __cookie);
    }

    void end_getVersion(::Ice::Int& major, ::Ice::Int& minor, ::Ice::Int& patch, ::std::string& text, const ::Ice::AsyncResultPtr&);
    
private:

    void getVersion(::Ice::Int&, ::Ice::Int&, ::Ice::Int&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addCallback(const ::Murmur::MetaCallbackPrx& cb)
    {
        addCallback(cb, 0);
    }
    void addCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::Context& __ctx)
    {
        addCallback(cb, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addCallback(const ::Murmur::MetaCallbackPrx& cb)
    {
        return begin_addCallback(cb, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::Context& __ctx)
    {
        return begin_addCallback(cb, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addCallback(cb, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addCallback(cb, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Murmur::Callback_Meta_addCallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addCallback(cb, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::Context& __ctx, const ::Murmur::Callback_Meta_addCallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addCallback(cb, &__ctx, __del, __cookie);
    }

    void end_addCallback(const ::Ice::AsyncResultPtr&);
    
private:

    void addCallback(const ::Murmur::MetaCallbackPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addCallback(const ::Murmur::MetaCallbackPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeCallback(const ::Murmur::MetaCallbackPrx& cb)
    {
        removeCallback(cb, 0);
    }
    void removeCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::Context& __ctx)
    {
        removeCallback(cb, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeCallback(const ::Murmur::MetaCallbackPrx& cb)
    {
        return begin_removeCallback(cb, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::Context& __ctx)
    {
        return begin_removeCallback(cb, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeCallback(cb, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeCallback(cb, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Murmur::Callback_Meta_removeCallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeCallback(cb, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeCallback(const ::Murmur::MetaCallbackPrx& cb, const ::Ice::Context& __ctx, const ::Murmur::Callback_Meta_removeCallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeCallback(cb, &__ctx, __del, __cookie);
    }

    void end_removeCallback(const ::Ice::AsyncResultPtr&);
    
private:

    void removeCallback(const ::Murmur::MetaCallbackPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeCallback(const ::Murmur::MetaCallbackPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getUptime()
    {
        return getUptime(0);
    }
    ::Ice::Int getUptime(const ::Ice::Context& __ctx)
    {
        return getUptime(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getUptime()
    {
        return begin_getUptime(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUptime(const ::Ice::Context& __ctx)
    {
        return begin_getUptime(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUptime(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUptime(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUptime(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUptime(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUptime(const ::Murmur::Callback_Meta_getUptimePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUptime(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUptime(const ::Ice::Context& __ctx, const ::Murmur::Callback_Meta_getUptimePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUptime(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_getUptime(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getUptime(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUptime(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getSlice()
    {
        return getSlice(0);
    }
    ::std::string getSlice(const ::Ice::Context& __ctx)
    {
        return getSlice(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSlice()
    {
        return begin_getSlice(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSlice(const ::Ice::Context& __ctx)
    {
        return begin_getSlice(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSlice(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSlice(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSlice(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSlice(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSlice(const ::Murmur::Callback_Meta_getSlicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSlice(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSlice(const ::Ice::Context& __ctx, const ::Murmur::Callback_Meta_getSlicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSlice(&__ctx, __del, __cookie);
    }

    ::std::string end_getSlice(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getSlice(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSlice(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::SliceChecksumDict getSliceChecksums()
    {
        return getSliceChecksums(0);
    }
    ::Ice::SliceChecksumDict getSliceChecksums(const ::Ice::Context& __ctx)
    {
        return getSliceChecksums(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSliceChecksums()
    {
        return begin_getSliceChecksums(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSliceChecksums(const ::Ice::Context& __ctx)
    {
        return begin_getSliceChecksums(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSliceChecksums(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSliceChecksums(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSliceChecksums(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSliceChecksums(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSliceChecksums(const ::Murmur::Callback_Meta_getSliceChecksumsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSliceChecksums(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSliceChecksums(const ::Ice::Context& __ctx, const ::Murmur::Callback_Meta_getSliceChecksumsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSliceChecksums(&__ctx, __del, __cookie);
    }

    ::Ice::SliceChecksumDict end_getSliceChecksums(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::SliceChecksumDict getSliceChecksums(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSliceChecksums(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<Meta> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Meta> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Meta*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<Meta*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace Murmur
{

class Tree : virtual public ::IceDelegate::Ice::Object
{
public:
};

class ServerCallback : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void userConnected(const ::Murmur::User&, const ::Ice::Context*) = 0;

    virtual void userDisconnected(const ::Murmur::User&, const ::Ice::Context*) = 0;

    virtual void userStateChanged(const ::Murmur::User&, const ::Ice::Context*) = 0;

    virtual void channelCreated(const ::Murmur::Channel&, const ::Ice::Context*) = 0;

    virtual void channelRemoved(const ::Murmur::Channel&, const ::Ice::Context*) = 0;

    virtual void channelStateChanged(const ::Murmur::Channel&, const ::Ice::Context*) = 0;
};

class ServerContextCallback : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void contextAction(const ::std::string&, const ::Murmur::User&, ::Ice::Int, ::Ice::Int, const ::Ice::Context*) = 0;
};

class ServerAuthenticator : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::Ice::Int authenticate(const ::std::string&, const ::std::string&, const ::Murmur::CertificateList&, const ::std::string&, bool, ::std::string&, ::Murmur::GroupNameList&, const ::Ice::Context*) = 0;

    virtual bool getInfo(::Ice::Int, ::Murmur::UserInfoMap&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int nameToId(const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::std::string idToName(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Murmur::Texture idToTexture(::Ice::Int, const ::Ice::Context*) = 0;
};

class ServerUpdatingAuthenticator : virtual public ::IceDelegate::Murmur::ServerAuthenticator
{
public:

    virtual ::Ice::Int registerUser(const ::Murmur::UserInfoMap&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int unregisterUser(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Murmur::NameMap getRegisteredUsers(const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int setInfo(::Ice::Int, const ::Murmur::UserInfoMap&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int setTexture(::Ice::Int, const ::Murmur::Texture&, const ::Ice::Context*) = 0;
};

class Server : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual bool isRunning(const ::Ice::Context*) = 0;

    virtual void start(const ::Ice::Context*) = 0;

    virtual void stop(const ::Ice::Context*) = 0;

    virtual void _cpp_delete(const ::Ice::Context*) = 0;

    virtual ::Ice::Int id(const ::Ice::Context*) = 0;

    virtual void addCallback(const ::Murmur::ServerCallbackPrx&, const ::Ice::Context*) = 0;

    virtual void removeCallback(const ::Murmur::ServerCallbackPrx&, const ::Ice::Context*) = 0;

    virtual void setAuthenticator(const ::Murmur::ServerAuthenticatorPrx&, const ::Ice::Context*) = 0;

    virtual ::std::string getConf(const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Murmur::ConfigMap getAllConf(const ::Ice::Context*) = 0;

    virtual void setConf(const ::std::string&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void setSuperuserPassword(const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Murmur::LogList getLog(::Ice::Int, ::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getLogLen(const ::Ice::Context*) = 0;

    virtual ::Murmur::UserMap getUsers(const ::Ice::Context*) = 0;

    virtual ::Murmur::ChannelMap getChannels(const ::Ice::Context*) = 0;

    virtual ::Murmur::CertificateList getCertificateList(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Murmur::TreePtr getTree(const ::Ice::Context*) = 0;

    virtual ::Murmur::BanList getBans(const ::Ice::Context*) = 0;

    virtual void setBans(const ::Murmur::BanList&, const ::Ice::Context*) = 0;

    virtual void kickUser(::Ice::Int, const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Murmur::User getState(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setState(const ::Murmur::User&, const ::Ice::Context*) = 0;

    virtual void sendMessage(::Ice::Int, const ::std::string&, const ::Ice::Context*) = 0;

    virtual bool hasPermission(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*) = 0;

    virtual void addContextCallback(::Ice::Int, const ::std::string&, const ::std::string&, const ::Murmur::ServerContextCallbackPrx&, ::Ice::Int, const ::Ice::Context*) = 0;

    virtual void removeContextCallback(const ::Murmur::ServerContextCallbackPrx&, const ::Ice::Context*) = 0;

    virtual ::Murmur::Channel getChannelState(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setChannelState(const ::Murmur::Channel&, const ::Ice::Context*) = 0;

    virtual void removeChannel(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int addChannel(const ::std::string&, ::Ice::Int, const ::Ice::Context*) = 0;

    virtual void sendMessageChannel(::Ice::Int, bool, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void getACL(::Ice::Int, ::Murmur::ACLList&, ::Murmur::GroupList&, bool&, const ::Ice::Context*) = 0;

    virtual void setACL(::Ice::Int, const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool, const ::Ice::Context*) = 0;

    virtual void addUserToGroup(::Ice::Int, ::Ice::Int, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void removeUserFromGroup(::Ice::Int, ::Ice::Int, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void redirectWhisperGroup(::Ice::Int, const ::std::string&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Murmur::NameMap getUserNames(const ::Murmur::IdList&, const ::Ice::Context*) = 0;

    virtual ::Murmur::IdMap getUserIds(const ::Murmur::NameList&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int registerUser(const ::Murmur::UserInfoMap&, const ::Ice::Context*) = 0;

    virtual void unregisterUser(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void updateRegistration(::Ice::Int, const ::Murmur::UserInfoMap&, const ::Ice::Context*) = 0;

    virtual ::Murmur::UserInfoMap getRegistration(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Murmur::NameMap getRegisteredUsers(const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int verifyPassword(const ::std::string&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Murmur::Texture getTexture(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setTexture(::Ice::Int, const ::Murmur::Texture&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getUptime(const ::Ice::Context*) = 0;
};

class MetaCallback : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void started(const ::Murmur::ServerPrx&, const ::Ice::Context*) = 0;

    virtual void stopped(const ::Murmur::ServerPrx&, const ::Ice::Context*) = 0;
};

class Meta : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::Murmur::ServerPrx getServer(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Murmur::ServerPrx newServer(const ::Ice::Context*) = 0;

    virtual ::Murmur::ServerList getBootedServers(const ::Ice::Context*) = 0;

    virtual ::Murmur::ServerList getAllServers(const ::Ice::Context*) = 0;

    virtual ::Murmur::ConfigMap getDefaultConf(const ::Ice::Context*) = 0;

    virtual void getVersion(::Ice::Int&, ::Ice::Int&, ::Ice::Int&, ::std::string&, const ::Ice::Context*) = 0;

    virtual void addCallback(const ::Murmur::MetaCallbackPrx&, const ::Ice::Context*) = 0;

    virtual void removeCallback(const ::Murmur::MetaCallbackPrx&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getUptime(const ::Ice::Context*) = 0;

    virtual ::std::string getSlice(const ::Ice::Context*) = 0;

    virtual ::Ice::SliceChecksumDict getSliceChecksums(const ::Ice::Context*) = 0;
};

}

}

namespace IceDelegateM
{

namespace Murmur
{

class Tree : virtual public ::IceDelegate::Murmur::Tree,
             virtual public ::IceDelegateM::Ice::Object
{
public:
};

class ServerCallback : virtual public ::IceDelegate::Murmur::ServerCallback,
                       virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void userConnected(const ::Murmur::User&, const ::Ice::Context*);

    virtual void userDisconnected(const ::Murmur::User&, const ::Ice::Context*);

    virtual void userStateChanged(const ::Murmur::User&, const ::Ice::Context*);

    virtual void channelCreated(const ::Murmur::Channel&, const ::Ice::Context*);

    virtual void channelRemoved(const ::Murmur::Channel&, const ::Ice::Context*);

    virtual void channelStateChanged(const ::Murmur::Channel&, const ::Ice::Context*);
};

class ServerContextCallback : virtual public ::IceDelegate::Murmur::ServerContextCallback,
                              virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void contextAction(const ::std::string&, const ::Murmur::User&, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
};

class ServerAuthenticator : virtual public ::IceDelegate::Murmur::ServerAuthenticator,
                            virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::Ice::Int authenticate(const ::std::string&, const ::std::string&, const ::Murmur::CertificateList&, const ::std::string&, bool, ::std::string&, ::Murmur::GroupNameList&, const ::Ice::Context*);

    virtual bool getInfo(::Ice::Int, ::Murmur::UserInfoMap&, const ::Ice::Context*);

    virtual ::Ice::Int nameToId(const ::std::string&, const ::Ice::Context*);

    virtual ::std::string idToName(::Ice::Int, const ::Ice::Context*);

    virtual ::Murmur::Texture idToTexture(::Ice::Int, const ::Ice::Context*);
};

class ServerUpdatingAuthenticator : virtual public ::IceDelegate::Murmur::ServerUpdatingAuthenticator,
                                    virtual public ::IceDelegateM::Murmur::ServerAuthenticator
{
public:

    virtual ::Ice::Int registerUser(const ::Murmur::UserInfoMap&, const ::Ice::Context*);

    virtual ::Ice::Int unregisterUser(::Ice::Int, const ::Ice::Context*);

    virtual ::Murmur::NameMap getRegisteredUsers(const ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int setInfo(::Ice::Int, const ::Murmur::UserInfoMap&, const ::Ice::Context*);

    virtual ::Ice::Int setTexture(::Ice::Int, const ::Murmur::Texture&, const ::Ice::Context*);
};

class Server : virtual public ::IceDelegate::Murmur::Server,
               virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual bool isRunning(const ::Ice::Context*);

    virtual void start(const ::Ice::Context*);

    virtual void stop(const ::Ice::Context*);

    virtual void _cpp_delete(const ::Ice::Context*);

    virtual ::Ice::Int id(const ::Ice::Context*);

    virtual void addCallback(const ::Murmur::ServerCallbackPrx&, const ::Ice::Context*);

    virtual void removeCallback(const ::Murmur::ServerCallbackPrx&, const ::Ice::Context*);

    virtual void setAuthenticator(const ::Murmur::ServerAuthenticatorPrx&, const ::Ice::Context*);

    virtual ::std::string getConf(const ::std::string&, const ::Ice::Context*);

    virtual ::Murmur::ConfigMap getAllConf(const ::Ice::Context*);

    virtual void setConf(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual void setSuperuserPassword(const ::std::string&, const ::Ice::Context*);

    virtual ::Murmur::LogList getLog(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getLogLen(const ::Ice::Context*);

    virtual ::Murmur::UserMap getUsers(const ::Ice::Context*);

    virtual ::Murmur::ChannelMap getChannels(const ::Ice::Context*);

    virtual ::Murmur::CertificateList getCertificateList(::Ice::Int, const ::Ice::Context*);

    virtual ::Murmur::TreePtr getTree(const ::Ice::Context*);

    virtual ::Murmur::BanList getBans(const ::Ice::Context*);

    virtual void setBans(const ::Murmur::BanList&, const ::Ice::Context*);

    virtual void kickUser(::Ice::Int, const ::std::string&, const ::Ice::Context*);

    virtual ::Murmur::User getState(::Ice::Int, const ::Ice::Context*);

    virtual void setState(const ::Murmur::User&, const ::Ice::Context*);

    virtual void sendMessage(::Ice::Int, const ::std::string&, const ::Ice::Context*);

    virtual bool hasPermission(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual void addContextCallback(::Ice::Int, const ::std::string&, const ::std::string&, const ::Murmur::ServerContextCallbackPrx&, ::Ice::Int, const ::Ice::Context*);

    virtual void removeContextCallback(const ::Murmur::ServerContextCallbackPrx&, const ::Ice::Context*);

    virtual ::Murmur::Channel getChannelState(::Ice::Int, const ::Ice::Context*);

    virtual void setChannelState(const ::Murmur::Channel&, const ::Ice::Context*);

    virtual void removeChannel(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int addChannel(const ::std::string&, ::Ice::Int, const ::Ice::Context*);

    virtual void sendMessageChannel(::Ice::Int, bool, const ::std::string&, const ::Ice::Context*);

    virtual void getACL(::Ice::Int, ::Murmur::ACLList&, ::Murmur::GroupList&, bool&, const ::Ice::Context*);

    virtual void setACL(::Ice::Int, const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool, const ::Ice::Context*);

    virtual void addUserToGroup(::Ice::Int, ::Ice::Int, const ::std::string&, const ::Ice::Context*);

    virtual void removeUserFromGroup(::Ice::Int, ::Ice::Int, const ::std::string&, const ::Ice::Context*);

    virtual void redirectWhisperGroup(::Ice::Int, const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual ::Murmur::NameMap getUserNames(const ::Murmur::IdList&, const ::Ice::Context*);

    virtual ::Murmur::IdMap getUserIds(const ::Murmur::NameList&, const ::Ice::Context*);

    virtual ::Ice::Int registerUser(const ::Murmur::UserInfoMap&, const ::Ice::Context*);

    virtual void unregisterUser(::Ice::Int, const ::Ice::Context*);

    virtual void updateRegistration(::Ice::Int, const ::Murmur::UserInfoMap&, const ::Ice::Context*);

    virtual ::Murmur::UserInfoMap getRegistration(::Ice::Int, const ::Ice::Context*);

    virtual ::Murmur::NameMap getRegisteredUsers(const ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int verifyPassword(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual ::Murmur::Texture getTexture(::Ice::Int, const ::Ice::Context*);

    virtual void setTexture(::Ice::Int, const ::Murmur::Texture&, const ::Ice::Context*);

    virtual ::Ice::Int getUptime(const ::Ice::Context*);
};

class MetaCallback : virtual public ::IceDelegate::Murmur::MetaCallback,
                     virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void started(const ::Murmur::ServerPrx&, const ::Ice::Context*);

    virtual void stopped(const ::Murmur::ServerPrx&, const ::Ice::Context*);
};

class Meta : virtual public ::IceDelegate::Murmur::Meta,
             virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::Murmur::ServerPrx getServer(::Ice::Int, const ::Ice::Context*);

    virtual ::Murmur::ServerPrx newServer(const ::Ice::Context*);

    virtual ::Murmur::ServerList getBootedServers(const ::Ice::Context*);

    virtual ::Murmur::ServerList getAllServers(const ::Ice::Context*);

    virtual ::Murmur::ConfigMap getDefaultConf(const ::Ice::Context*);

    virtual void getVersion(::Ice::Int&, ::Ice::Int&, ::Ice::Int&, ::std::string&, const ::Ice::Context*);

    virtual void addCallback(const ::Murmur::MetaCallbackPrx&, const ::Ice::Context*);

    virtual void removeCallback(const ::Murmur::MetaCallbackPrx&, const ::Ice::Context*);

    virtual ::Ice::Int getUptime(const ::Ice::Context*);

    virtual ::std::string getSlice(const ::Ice::Context*);

    virtual ::Ice::SliceChecksumDict getSliceChecksums(const ::Ice::Context*);
};

}

}

namespace IceDelegateD
{

namespace Murmur
{

class Tree : virtual public ::IceDelegate::Murmur::Tree,
             virtual public ::IceDelegateD::Ice::Object
{
public:
};

class ServerCallback : virtual public ::IceDelegate::Murmur::ServerCallback,
                       virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void userConnected(const ::Murmur::User&, const ::Ice::Context*);

    virtual void userDisconnected(const ::Murmur::User&, const ::Ice::Context*);

    virtual void userStateChanged(const ::Murmur::User&, const ::Ice::Context*);

    virtual void channelCreated(const ::Murmur::Channel&, const ::Ice::Context*);

    virtual void channelRemoved(const ::Murmur::Channel&, const ::Ice::Context*);

    virtual void channelStateChanged(const ::Murmur::Channel&, const ::Ice::Context*);
};

class ServerContextCallback : virtual public ::IceDelegate::Murmur::ServerContextCallback,
                              virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void contextAction(const ::std::string&, const ::Murmur::User&, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
};

class ServerAuthenticator : virtual public ::IceDelegate::Murmur::ServerAuthenticator,
                            virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::Ice::Int authenticate(const ::std::string&, const ::std::string&, const ::Murmur::CertificateList&, const ::std::string&, bool, ::std::string&, ::Murmur::GroupNameList&, const ::Ice::Context*);

    virtual bool getInfo(::Ice::Int, ::Murmur::UserInfoMap&, const ::Ice::Context*);

    virtual ::Ice::Int nameToId(const ::std::string&, const ::Ice::Context*);

    virtual ::std::string idToName(::Ice::Int, const ::Ice::Context*);

    virtual ::Murmur::Texture idToTexture(::Ice::Int, const ::Ice::Context*);
};

class ServerUpdatingAuthenticator : virtual public ::IceDelegate::Murmur::ServerUpdatingAuthenticator,
                                    virtual public ::IceDelegateD::Murmur::ServerAuthenticator
{
public:

    virtual ::Ice::Int registerUser(const ::Murmur::UserInfoMap&, const ::Ice::Context*);

    virtual ::Ice::Int unregisterUser(::Ice::Int, const ::Ice::Context*);

    virtual ::Murmur::NameMap getRegisteredUsers(const ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int setInfo(::Ice::Int, const ::Murmur::UserInfoMap&, const ::Ice::Context*);

    virtual ::Ice::Int setTexture(::Ice::Int, const ::Murmur::Texture&, const ::Ice::Context*);
};

class Server : virtual public ::IceDelegate::Murmur::Server,
               virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual bool isRunning(const ::Ice::Context*);

    virtual void start(const ::Ice::Context*);

    virtual void stop(const ::Ice::Context*);

    virtual void _cpp_delete(const ::Ice::Context*);

    virtual ::Ice::Int id(const ::Ice::Context*);

    virtual void addCallback(const ::Murmur::ServerCallbackPrx&, const ::Ice::Context*);

    virtual void removeCallback(const ::Murmur::ServerCallbackPrx&, const ::Ice::Context*);

    virtual void setAuthenticator(const ::Murmur::ServerAuthenticatorPrx&, const ::Ice::Context*);

    virtual ::std::string getConf(const ::std::string&, const ::Ice::Context*);

    virtual ::Murmur::ConfigMap getAllConf(const ::Ice::Context*);

    virtual void setConf(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual void setSuperuserPassword(const ::std::string&, const ::Ice::Context*);

    virtual ::Murmur::LogList getLog(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getLogLen(const ::Ice::Context*);

    virtual ::Murmur::UserMap getUsers(const ::Ice::Context*);

    virtual ::Murmur::ChannelMap getChannels(const ::Ice::Context*);

    virtual ::Murmur::CertificateList getCertificateList(::Ice::Int, const ::Ice::Context*);

    virtual ::Murmur::TreePtr getTree(const ::Ice::Context*);

    virtual ::Murmur::BanList getBans(const ::Ice::Context*);

    virtual void setBans(const ::Murmur::BanList&, const ::Ice::Context*);

    virtual void kickUser(::Ice::Int, const ::std::string&, const ::Ice::Context*);

    virtual ::Murmur::User getState(::Ice::Int, const ::Ice::Context*);

    virtual void setState(const ::Murmur::User&, const ::Ice::Context*);

    virtual void sendMessage(::Ice::Int, const ::std::string&, const ::Ice::Context*);

    virtual bool hasPermission(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual void addContextCallback(::Ice::Int, const ::std::string&, const ::std::string&, const ::Murmur::ServerContextCallbackPrx&, ::Ice::Int, const ::Ice::Context*);

    virtual void removeContextCallback(const ::Murmur::ServerContextCallbackPrx&, const ::Ice::Context*);

    virtual ::Murmur::Channel getChannelState(::Ice::Int, const ::Ice::Context*);

    virtual void setChannelState(const ::Murmur::Channel&, const ::Ice::Context*);

    virtual void removeChannel(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int addChannel(const ::std::string&, ::Ice::Int, const ::Ice::Context*);

    virtual void sendMessageChannel(::Ice::Int, bool, const ::std::string&, const ::Ice::Context*);

    virtual void getACL(::Ice::Int, ::Murmur::ACLList&, ::Murmur::GroupList&, bool&, const ::Ice::Context*);

    virtual void setACL(::Ice::Int, const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool, const ::Ice::Context*);

    virtual void addUserToGroup(::Ice::Int, ::Ice::Int, const ::std::string&, const ::Ice::Context*);

    virtual void removeUserFromGroup(::Ice::Int, ::Ice::Int, const ::std::string&, const ::Ice::Context*);

    virtual void redirectWhisperGroup(::Ice::Int, const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual ::Murmur::NameMap getUserNames(const ::Murmur::IdList&, const ::Ice::Context*);

    virtual ::Murmur::IdMap getUserIds(const ::Murmur::NameList&, const ::Ice::Context*);

    virtual ::Ice::Int registerUser(const ::Murmur::UserInfoMap&, const ::Ice::Context*);

    virtual void unregisterUser(::Ice::Int, const ::Ice::Context*);

    virtual void updateRegistration(::Ice::Int, const ::Murmur::UserInfoMap&, const ::Ice::Context*);

    virtual ::Murmur::UserInfoMap getRegistration(::Ice::Int, const ::Ice::Context*);

    virtual ::Murmur::NameMap getRegisteredUsers(const ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int verifyPassword(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual ::Murmur::Texture getTexture(::Ice::Int, const ::Ice::Context*);

    virtual void setTexture(::Ice::Int, const ::Murmur::Texture&, const ::Ice::Context*);

    virtual ::Ice::Int getUptime(const ::Ice::Context*);
};

class MetaCallback : virtual public ::IceDelegate::Murmur::MetaCallback,
                     virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void started(const ::Murmur::ServerPrx&, const ::Ice::Context*);

    virtual void stopped(const ::Murmur::ServerPrx&, const ::Ice::Context*);
};

class Meta : virtual public ::IceDelegate::Murmur::Meta,
             virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::Murmur::ServerPrx getServer(::Ice::Int, const ::Ice::Context*);

    virtual ::Murmur::ServerPrx newServer(const ::Ice::Context*);

    virtual ::Murmur::ServerList getBootedServers(const ::Ice::Context*);

    virtual ::Murmur::ServerList getAllServers(const ::Ice::Context*);

    virtual ::Murmur::ConfigMap getDefaultConf(const ::Ice::Context*);

    virtual void getVersion(::Ice::Int&, ::Ice::Int&, ::Ice::Int&, ::std::string&, const ::Ice::Context*);

    virtual void addCallback(const ::Murmur::MetaCallbackPrx&, const ::Ice::Context*);

    virtual void removeCallback(const ::Murmur::MetaCallbackPrx&, const ::Ice::Context*);

    virtual ::Ice::Int getUptime(const ::Ice::Context*);

    virtual ::std::string getSlice(const ::Ice::Context*);

    virtual ::Ice::SliceChecksumDict getSliceChecksums(const ::Ice::Context*);
};

}

}

namespace Murmur
{

class Tree : virtual public ::Ice::Object, private IceInternal::GCShared
{
public:

    typedef TreePrx ProxyType;
    typedef TreePtr PointerType;
    
    Tree() {}
    Tree(const ::Murmur::Channel&, const ::Murmur::TreeList&, const ::Murmur::UserList&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesClasses();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~Tree() {}

    friend class Tree__staticInit;

public:

    ::Murmur::Channel c;

    ::Murmur::TreeList children;

    ::Murmur::UserList users;
};

class Tree__staticInit
{
public:

    ::Murmur::Tree _init;
};

static Tree__staticInit _Tree_init;

inline bool operator==(const Tree& l, const Tree& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Tree& l, const Tree& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ServerCallback : virtual public ::Ice::Object
{
public:

    typedef ServerCallbackPrx ProxyType;
    typedef ServerCallbackPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void userConnected(const ::Murmur::User&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___userConnected(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void userDisconnected(const ::Murmur::User&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___userDisconnected(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void userStateChanged(const ::Murmur::User&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___userStateChanged(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void channelCreated(const ::Murmur::Channel&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___channelCreated(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void channelRemoved(const ::Murmur::Channel&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___channelRemoved(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void channelStateChanged(const ::Murmur::Channel&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___channelStateChanged(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const ServerCallback& l, const ServerCallback& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ServerCallback& l, const ServerCallback& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ServerContextCallback : virtual public ::Ice::Object
{
public:

    typedef ServerContextCallbackPrx ProxyType;
    typedef ServerContextCallbackPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void contextAction(const ::std::string&, const ::Murmur::User&, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___contextAction(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const ServerContextCallback& l, const ServerContextCallback& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ServerContextCallback& l, const ServerContextCallback& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ServerAuthenticator : virtual public ::Ice::Object
{
public:

    typedef ServerAuthenticatorPrx ProxyType;
    typedef ServerAuthenticatorPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int authenticate(const ::std::string&, const ::std::string&, const ::Murmur::CertificateList&, const ::std::string&, bool, ::std::string&, ::Murmur::GroupNameList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___authenticate(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getInfo(::Ice::Int, ::Murmur::UserInfoMap&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getInfo(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int nameToId(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___nameToId(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string idToName(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___idToName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Murmur::Texture idToTexture(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___idToTexture(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const ServerAuthenticator& l, const ServerAuthenticator& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ServerAuthenticator& l, const ServerAuthenticator& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ServerUpdatingAuthenticator : virtual public ::Murmur::ServerAuthenticator
{
public:

    typedef ServerUpdatingAuthenticatorPrx ProxyType;
    typedef ServerUpdatingAuthenticatorPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int registerUser(const ::Murmur::UserInfoMap&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___registerUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int unregisterUser(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___unregisterUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Murmur::NameMap getRegisteredUsers(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRegisteredUsers(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int setInfo(::Ice::Int, const ::Murmur::UserInfoMap&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setInfo(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int setTexture(::Ice::Int, const ::Murmur::Texture&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setTexture(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const ServerUpdatingAuthenticator& l, const ServerUpdatingAuthenticator& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ServerUpdatingAuthenticator& l, const ServerUpdatingAuthenticator& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Server : virtual public ::Ice::Object
{
public:

    typedef ServerPrx ProxyType;
    typedef ServerPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void isRunning_async(const ::Murmur::AMD_Server_isRunningPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___isRunning(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void start_async(const ::Murmur::AMD_Server_startPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___start(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void stop_async(const ::Murmur::AMD_Server_stopPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___stop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void delete_async(const ::Murmur::AMD_Server_deletePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___delete(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void id_async(const ::Murmur::AMD_Server_idPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___id(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addCallback_async(const ::Murmur::AMD_Server_addCallbackPtr&, const ::Murmur::ServerCallbackPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addCallback(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeCallback_async(const ::Murmur::AMD_Server_removeCallbackPtr&, const ::Murmur::ServerCallbackPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeCallback(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAuthenticator_async(const ::Murmur::AMD_Server_setAuthenticatorPtr&, const ::Murmur::ServerAuthenticatorPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAuthenticator(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getConf_async(const ::Murmur::AMD_Server_getConfPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getConf(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getAllConf_async(const ::Murmur::AMD_Server_getAllConfPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAllConf(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setConf_async(const ::Murmur::AMD_Server_setConfPtr&, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setConf(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setSuperuserPassword_async(const ::Murmur::AMD_Server_setSuperuserPasswordPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setSuperuserPassword(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getLog_async(const ::Murmur::AMD_Server_getLogPtr&, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getLog(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getLogLen_async(const ::Murmur::AMD_Server_getLogLenPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getLogLen(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getUsers_async(const ::Murmur::AMD_Server_getUsersPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUsers(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getChannels_async(const ::Murmur::AMD_Server_getChannelsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getChannels(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getCertificateList_async(const ::Murmur::AMD_Server_getCertificateListPtr&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getCertificateList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getTree_async(const ::Murmur::AMD_Server_getTreePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTree(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getBans_async(const ::Murmur::AMD_Server_getBansPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getBans(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setBans_async(const ::Murmur::AMD_Server_setBansPtr&, const ::Murmur::BanList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setBans(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void kickUser_async(const ::Murmur::AMD_Server_kickUserPtr&, ::Ice::Int, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___kickUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getState_async(const ::Murmur::AMD_Server_getStatePtr&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getState(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setState_async(const ::Murmur::AMD_Server_setStatePtr&, const ::Murmur::User&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setState(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void sendMessage_async(const ::Murmur::AMD_Server_sendMessagePtr&, ::Ice::Int, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sendMessage(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void hasPermission_async(const ::Murmur::AMD_Server_hasPermissionPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___hasPermission(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addContextCallback_async(const ::Murmur::AMD_Server_addContextCallbackPtr&, ::Ice::Int, const ::std::string&, const ::std::string&, const ::Murmur::ServerContextCallbackPrx&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addContextCallback(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeContextCallback_async(const ::Murmur::AMD_Server_removeContextCallbackPtr&, const ::Murmur::ServerContextCallbackPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeContextCallback(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getChannelState_async(const ::Murmur::AMD_Server_getChannelStatePtr&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getChannelState(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setChannelState_async(const ::Murmur::AMD_Server_setChannelStatePtr&, const ::Murmur::Channel&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setChannelState(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeChannel_async(const ::Murmur::AMD_Server_removeChannelPtr&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeChannel(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addChannel_async(const ::Murmur::AMD_Server_addChannelPtr&, const ::std::string&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addChannel(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void sendMessageChannel_async(const ::Murmur::AMD_Server_sendMessageChannelPtr&, ::Ice::Int, bool, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sendMessageChannel(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getACL_async(const ::Murmur::AMD_Server_getACLPtr&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getACL(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setACL_async(const ::Murmur::AMD_Server_setACLPtr&, ::Ice::Int, const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setACL(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addUserToGroup_async(const ::Murmur::AMD_Server_addUserToGroupPtr&, ::Ice::Int, ::Ice::Int, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addUserToGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeUserFromGroup_async(const ::Murmur::AMD_Server_removeUserFromGroupPtr&, ::Ice::Int, ::Ice::Int, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeUserFromGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void redirectWhisperGroup_async(const ::Murmur::AMD_Server_redirectWhisperGroupPtr&, ::Ice::Int, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___redirectWhisperGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getUserNames_async(const ::Murmur::AMD_Server_getUserNamesPtr&, const ::Murmur::IdList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUserNames(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getUserIds_async(const ::Murmur::AMD_Server_getUserIdsPtr&, const ::Murmur::NameList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUserIds(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void registerUser_async(const ::Murmur::AMD_Server_registerUserPtr&, const ::Murmur::UserInfoMap&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___registerUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void unregisterUser_async(const ::Murmur::AMD_Server_unregisterUserPtr&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___unregisterUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void updateRegistration_async(const ::Murmur::AMD_Server_updateRegistrationPtr&, ::Ice::Int, const ::Murmur::UserInfoMap&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___updateRegistration(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getRegistration_async(const ::Murmur::AMD_Server_getRegistrationPtr&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRegistration(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getRegisteredUsers_async(const ::Murmur::AMD_Server_getRegisteredUsersPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRegisteredUsers(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void verifyPassword_async(const ::Murmur::AMD_Server_verifyPasswordPtr&, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___verifyPassword(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getTexture_async(const ::Murmur::AMD_Server_getTexturePtr&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTexture(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setTexture_async(const ::Murmur::AMD_Server_setTexturePtr&, ::Ice::Int, const ::Murmur::Texture&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setTexture(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getUptime_async(const ::Murmur::AMD_Server_getUptimePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUptime(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const Server& l, const Server& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Server& l, const Server& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class MetaCallback : virtual public ::Ice::Object
{
public:

    typedef MetaCallbackPrx ProxyType;
    typedef MetaCallbackPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void started(const ::Murmur::ServerPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___started(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void stopped(const ::Murmur::ServerPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___stopped(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const MetaCallback& l, const MetaCallback& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MetaCallback& l, const MetaCallback& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Meta : virtual public ::Ice::Object
{
public:

    typedef MetaPrx ProxyType;
    typedef MetaPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void getServer_async(const ::Murmur::AMD_Meta_getServerPtr&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getServer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void newServer_async(const ::Murmur::AMD_Meta_newServerPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___newServer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getBootedServers_async(const ::Murmur::AMD_Meta_getBootedServersPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getBootedServers(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getAllServers_async(const ::Murmur::AMD_Meta_getAllServersPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAllServers(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getDefaultConf_async(const ::Murmur::AMD_Meta_getDefaultConfPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getDefaultConf(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getVersion_async(const ::Murmur::AMD_Meta_getVersionPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getVersion(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addCallback_async(const ::Murmur::AMD_Meta_addCallbackPtr&, const ::Murmur::MetaCallbackPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addCallback(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeCallback_async(const ::Murmur::AMD_Meta_removeCallbackPtr&, const ::Murmur::MetaCallbackPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeCallback(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getUptime_async(const ::Murmur::AMD_Meta_getUptimePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUptime(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getSlice_async(const ::Murmur::AMD_Meta_getSlicePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSlice(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getSliceChecksums_async(const ::Murmur::AMD_Meta_getSliceChecksumsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSliceChecksums(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const Meta& l, const Meta& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Meta& l, const Meta& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace Murmur
{

template<class T>
class CallbackNC_ServerCallback_userConnected : public Callback_ServerCallback_userConnected_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ServerCallback_userConnected(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ServerCallback_userConnectedPtr
newCallback_ServerCallback_userConnected(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_userConnected<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerCallback_userConnectedPtr
newCallback_ServerCallback_userConnected(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_userConnected<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ServerCallback_userConnectedPtr
newCallback_ServerCallback_userConnected(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_userConnected<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerCallback_userConnectedPtr
newCallback_ServerCallback_userConnected(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_userConnected<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerCallback_userConnected : public Callback_ServerCallback_userConnected_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ServerCallback_userConnected(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ServerCallback_userConnectedPtr
newCallback_ServerCallback_userConnected(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_userConnected<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_userConnectedPtr
newCallback_ServerCallback_userConnected(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_userConnected<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_userConnectedPtr
newCallback_ServerCallback_userConnected(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_userConnected<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_userConnectedPtr
newCallback_ServerCallback_userConnected(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_userConnected<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServerCallback_userDisconnected : public Callback_ServerCallback_userDisconnected_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ServerCallback_userDisconnected(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ServerCallback_userDisconnectedPtr
newCallback_ServerCallback_userDisconnected(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_userDisconnected<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerCallback_userDisconnectedPtr
newCallback_ServerCallback_userDisconnected(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_userDisconnected<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ServerCallback_userDisconnectedPtr
newCallback_ServerCallback_userDisconnected(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_userDisconnected<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerCallback_userDisconnectedPtr
newCallback_ServerCallback_userDisconnected(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_userDisconnected<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerCallback_userDisconnected : public Callback_ServerCallback_userDisconnected_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ServerCallback_userDisconnected(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ServerCallback_userDisconnectedPtr
newCallback_ServerCallback_userDisconnected(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_userDisconnected<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_userDisconnectedPtr
newCallback_ServerCallback_userDisconnected(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_userDisconnected<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_userDisconnectedPtr
newCallback_ServerCallback_userDisconnected(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_userDisconnected<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_userDisconnectedPtr
newCallback_ServerCallback_userDisconnected(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_userDisconnected<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServerCallback_userStateChanged : public Callback_ServerCallback_userStateChanged_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ServerCallback_userStateChanged(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ServerCallback_userStateChangedPtr
newCallback_ServerCallback_userStateChanged(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_userStateChanged<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerCallback_userStateChangedPtr
newCallback_ServerCallback_userStateChanged(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_userStateChanged<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ServerCallback_userStateChangedPtr
newCallback_ServerCallback_userStateChanged(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_userStateChanged<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerCallback_userStateChangedPtr
newCallback_ServerCallback_userStateChanged(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_userStateChanged<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerCallback_userStateChanged : public Callback_ServerCallback_userStateChanged_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ServerCallback_userStateChanged(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ServerCallback_userStateChangedPtr
newCallback_ServerCallback_userStateChanged(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_userStateChanged<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_userStateChangedPtr
newCallback_ServerCallback_userStateChanged(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_userStateChanged<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_userStateChangedPtr
newCallback_ServerCallback_userStateChanged(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_userStateChanged<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_userStateChangedPtr
newCallback_ServerCallback_userStateChanged(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_userStateChanged<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServerCallback_channelCreated : public Callback_ServerCallback_channelCreated_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ServerCallback_channelCreated(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ServerCallback_channelCreatedPtr
newCallback_ServerCallback_channelCreated(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_channelCreated<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerCallback_channelCreatedPtr
newCallback_ServerCallback_channelCreated(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_channelCreated<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ServerCallback_channelCreatedPtr
newCallback_ServerCallback_channelCreated(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_channelCreated<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerCallback_channelCreatedPtr
newCallback_ServerCallback_channelCreated(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_channelCreated<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerCallback_channelCreated : public Callback_ServerCallback_channelCreated_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ServerCallback_channelCreated(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ServerCallback_channelCreatedPtr
newCallback_ServerCallback_channelCreated(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_channelCreated<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_channelCreatedPtr
newCallback_ServerCallback_channelCreated(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_channelCreated<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_channelCreatedPtr
newCallback_ServerCallback_channelCreated(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_channelCreated<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_channelCreatedPtr
newCallback_ServerCallback_channelCreated(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_channelCreated<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServerCallback_channelRemoved : public Callback_ServerCallback_channelRemoved_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ServerCallback_channelRemoved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ServerCallback_channelRemovedPtr
newCallback_ServerCallback_channelRemoved(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_channelRemoved<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerCallback_channelRemovedPtr
newCallback_ServerCallback_channelRemoved(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_channelRemoved<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ServerCallback_channelRemovedPtr
newCallback_ServerCallback_channelRemoved(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_channelRemoved<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerCallback_channelRemovedPtr
newCallback_ServerCallback_channelRemoved(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_channelRemoved<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerCallback_channelRemoved : public Callback_ServerCallback_channelRemoved_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ServerCallback_channelRemoved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ServerCallback_channelRemovedPtr
newCallback_ServerCallback_channelRemoved(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_channelRemoved<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_channelRemovedPtr
newCallback_ServerCallback_channelRemoved(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_channelRemoved<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_channelRemovedPtr
newCallback_ServerCallback_channelRemoved(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_channelRemoved<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_channelRemovedPtr
newCallback_ServerCallback_channelRemoved(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_channelRemoved<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServerCallback_channelStateChanged : public Callback_ServerCallback_channelStateChanged_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ServerCallback_channelStateChanged(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ServerCallback_channelStateChangedPtr
newCallback_ServerCallback_channelStateChanged(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_channelStateChanged<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerCallback_channelStateChangedPtr
newCallback_ServerCallback_channelStateChanged(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_channelStateChanged<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ServerCallback_channelStateChangedPtr
newCallback_ServerCallback_channelStateChanged(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_channelStateChanged<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerCallback_channelStateChangedPtr
newCallback_ServerCallback_channelStateChanged(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerCallback_channelStateChanged<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerCallback_channelStateChanged : public Callback_ServerCallback_channelStateChanged_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ServerCallback_channelStateChanged(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ServerCallback_channelStateChangedPtr
newCallback_ServerCallback_channelStateChanged(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_channelStateChanged<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_channelStateChangedPtr
newCallback_ServerCallback_channelStateChanged(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_channelStateChanged<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_channelStateChangedPtr
newCallback_ServerCallback_channelStateChanged(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_channelStateChanged<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerCallback_channelStateChangedPtr
newCallback_ServerCallback_channelStateChanged(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerCallback_channelStateChanged<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServerContextCallback_contextAction : public Callback_ServerContextCallback_contextAction_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ServerContextCallback_contextAction(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ServerContextCallback_contextActionPtr
newCallback_ServerContextCallback_contextAction(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerContextCallback_contextAction<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerContextCallback_contextActionPtr
newCallback_ServerContextCallback_contextAction(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerContextCallback_contextAction<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ServerContextCallback_contextActionPtr
newCallback_ServerContextCallback_contextAction(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerContextCallback_contextAction<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerContextCallback_contextActionPtr
newCallback_ServerContextCallback_contextAction(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerContextCallback_contextAction<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerContextCallback_contextAction : public Callback_ServerContextCallback_contextAction_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ServerContextCallback_contextAction(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ServerContextCallback_contextActionPtr
newCallback_ServerContextCallback_contextAction(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerContextCallback_contextAction<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerContextCallback_contextActionPtr
newCallback_ServerContextCallback_contextAction(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerContextCallback_contextAction<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ServerContextCallback_contextActionPtr
newCallback_ServerContextCallback_contextAction(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerContextCallback_contextAction<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerContextCallback_contextActionPtr
newCallback_ServerContextCallback_contextAction(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerContextCallback_contextAction<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServerAuthenticator_authenticate : public Callback_ServerAuthenticator_authenticate_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const ::Murmur::GroupNameList&);

    CallbackNC_ServerAuthenticator_authenticate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerAuthenticatorPrx __proxy = ::Murmur::ServerAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::std::string newname;
        ::Murmur::GroupNameList groups;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_authenticate(newname, groups, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, newname, groups);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, newname, groups);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerAuthenticator_authenticatePtr
newCallback_ServerAuthenticator_authenticate(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::Murmur::GroupNameList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAuthenticator_authenticate<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerAuthenticator_authenticatePtr
newCallback_ServerAuthenticator_authenticate(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::Murmur::GroupNameList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAuthenticator_authenticate<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerAuthenticator_authenticate : public Callback_ServerAuthenticator_authenticate_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const ::Murmur::GroupNameList&, const CT&);

    Callback_ServerAuthenticator_authenticate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerAuthenticatorPrx __proxy = ::Murmur::ServerAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::std::string newname;
        ::Murmur::GroupNameList groups;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_authenticate(newname, groups, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, newname, groups, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, newname, groups, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerAuthenticator_authenticatePtr
newCallback_ServerAuthenticator_authenticate(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::Murmur::GroupNameList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAuthenticator_authenticate<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerAuthenticator_authenticatePtr
newCallback_ServerAuthenticator_authenticate(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::Murmur::GroupNameList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAuthenticator_authenticate<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerAuthenticator_getInfo : public Callback_ServerAuthenticator_getInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const ::Murmur::UserInfoMap&);

    CallbackNC_ServerAuthenticator_getInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerAuthenticatorPrx __proxy = ::Murmur::ServerAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Murmur::UserInfoMap info;
        bool __ret;
        try
        {
            __ret = __proxy->end_getInfo(info, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, info);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, info);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerAuthenticator_getInfoPtr
newCallback_ServerAuthenticator_getInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::Murmur::UserInfoMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAuthenticator_getInfo<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerAuthenticator_getInfoPtr
newCallback_ServerAuthenticator_getInfo(T* instance, void (T::*cb)(bool, const ::Murmur::UserInfoMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAuthenticator_getInfo<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerAuthenticator_getInfo : public Callback_ServerAuthenticator_getInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const ::Murmur::UserInfoMap&, const CT&);

    Callback_ServerAuthenticator_getInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerAuthenticatorPrx __proxy = ::Murmur::ServerAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Murmur::UserInfoMap info;
        bool __ret;
        try
        {
            __ret = __proxy->end_getInfo(info, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, info, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, info, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerAuthenticator_getInfoPtr
newCallback_ServerAuthenticator_getInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::Murmur::UserInfoMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAuthenticator_getInfo<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerAuthenticator_getInfoPtr
newCallback_ServerAuthenticator_getInfo(T* instance, void (T::*cb)(bool, const ::Murmur::UserInfoMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAuthenticator_getInfo<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerAuthenticator_nameToId : public Callback_ServerAuthenticator_nameToId_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_ServerAuthenticator_nameToId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerAuthenticatorPrx __proxy = ::Murmur::ServerAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_nameToId(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerAuthenticator_nameToIdPtr
newCallback_ServerAuthenticator_nameToId(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAuthenticator_nameToId<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerAuthenticator_nameToIdPtr
newCallback_ServerAuthenticator_nameToId(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAuthenticator_nameToId<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerAuthenticator_nameToId : public Callback_ServerAuthenticator_nameToId_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_ServerAuthenticator_nameToId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerAuthenticatorPrx __proxy = ::Murmur::ServerAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_nameToId(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerAuthenticator_nameToIdPtr
newCallback_ServerAuthenticator_nameToId(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAuthenticator_nameToId<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerAuthenticator_nameToIdPtr
newCallback_ServerAuthenticator_nameToId(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAuthenticator_nameToId<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerAuthenticator_idToName : public Callback_ServerAuthenticator_idToName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_ServerAuthenticator_idToName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerAuthenticatorPrx __proxy = ::Murmur::ServerAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_idToName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerAuthenticator_idToNamePtr
newCallback_ServerAuthenticator_idToName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAuthenticator_idToName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerAuthenticator_idToNamePtr
newCallback_ServerAuthenticator_idToName(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAuthenticator_idToName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerAuthenticator_idToName : public Callback_ServerAuthenticator_idToName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_ServerAuthenticator_idToName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerAuthenticatorPrx __proxy = ::Murmur::ServerAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_idToName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerAuthenticator_idToNamePtr
newCallback_ServerAuthenticator_idToName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAuthenticator_idToName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerAuthenticator_idToNamePtr
newCallback_ServerAuthenticator_idToName(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAuthenticator_idToName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerAuthenticator_idToTexture : public Callback_ServerAuthenticator_idToTexture_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::Texture&);

    CallbackNC_ServerAuthenticator_idToTexture(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerAuthenticatorPrx __proxy = ::Murmur::ServerAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Murmur::Texture __ret;
        try
        {
            __ret = __proxy->end_idToTexture(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerAuthenticator_idToTexturePtr
newCallback_ServerAuthenticator_idToTexture(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::Texture&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAuthenticator_idToTexture<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerAuthenticator_idToTexturePtr
newCallback_ServerAuthenticator_idToTexture(T* instance, void (T::*cb)(const ::Murmur::Texture&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAuthenticator_idToTexture<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerAuthenticator_idToTexture : public Callback_ServerAuthenticator_idToTexture_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::Texture&, const CT&);

    Callback_ServerAuthenticator_idToTexture(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerAuthenticatorPrx __proxy = ::Murmur::ServerAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Murmur::Texture __ret;
        try
        {
            __ret = __proxy->end_idToTexture(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerAuthenticator_idToTexturePtr
newCallback_ServerAuthenticator_idToTexture(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::Texture&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAuthenticator_idToTexture<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerAuthenticator_idToTexturePtr
newCallback_ServerAuthenticator_idToTexture(T* instance, void (T::*cb)(const ::Murmur::Texture&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAuthenticator_idToTexture<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerUpdatingAuthenticator_registerUser : public Callback_ServerUpdatingAuthenticator_registerUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_ServerUpdatingAuthenticator_registerUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerUpdatingAuthenticatorPrx __proxy = ::Murmur::ServerUpdatingAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_registerUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerUpdatingAuthenticator_registerUserPtr
newCallback_ServerUpdatingAuthenticator_registerUser(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerUpdatingAuthenticator_registerUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerUpdatingAuthenticator_registerUserPtr
newCallback_ServerUpdatingAuthenticator_registerUser(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerUpdatingAuthenticator_registerUser<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerUpdatingAuthenticator_registerUser : public Callback_ServerUpdatingAuthenticator_registerUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_ServerUpdatingAuthenticator_registerUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerUpdatingAuthenticatorPrx __proxy = ::Murmur::ServerUpdatingAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_registerUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerUpdatingAuthenticator_registerUserPtr
newCallback_ServerUpdatingAuthenticator_registerUser(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerUpdatingAuthenticator_registerUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerUpdatingAuthenticator_registerUserPtr
newCallback_ServerUpdatingAuthenticator_registerUser(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerUpdatingAuthenticator_registerUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerUpdatingAuthenticator_unregisterUser : public Callback_ServerUpdatingAuthenticator_unregisterUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_ServerUpdatingAuthenticator_unregisterUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerUpdatingAuthenticatorPrx __proxy = ::Murmur::ServerUpdatingAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_unregisterUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerUpdatingAuthenticator_unregisterUserPtr
newCallback_ServerUpdatingAuthenticator_unregisterUser(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerUpdatingAuthenticator_unregisterUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerUpdatingAuthenticator_unregisterUserPtr
newCallback_ServerUpdatingAuthenticator_unregisterUser(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerUpdatingAuthenticator_unregisterUser<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerUpdatingAuthenticator_unregisterUser : public Callback_ServerUpdatingAuthenticator_unregisterUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_ServerUpdatingAuthenticator_unregisterUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerUpdatingAuthenticatorPrx __proxy = ::Murmur::ServerUpdatingAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_unregisterUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerUpdatingAuthenticator_unregisterUserPtr
newCallback_ServerUpdatingAuthenticator_unregisterUser(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerUpdatingAuthenticator_unregisterUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerUpdatingAuthenticator_unregisterUserPtr
newCallback_ServerUpdatingAuthenticator_unregisterUser(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerUpdatingAuthenticator_unregisterUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerUpdatingAuthenticator_getRegisteredUsers : public Callback_ServerUpdatingAuthenticator_getRegisteredUsers_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::NameMap&);

    CallbackNC_ServerUpdatingAuthenticator_getRegisteredUsers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerUpdatingAuthenticatorPrx __proxy = ::Murmur::ServerUpdatingAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Murmur::NameMap __ret;
        try
        {
            __ret = __proxy->end_getRegisteredUsers(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerUpdatingAuthenticator_getRegisteredUsersPtr
newCallback_ServerUpdatingAuthenticator_getRegisteredUsers(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::NameMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerUpdatingAuthenticator_getRegisteredUsers<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerUpdatingAuthenticator_getRegisteredUsersPtr
newCallback_ServerUpdatingAuthenticator_getRegisteredUsers(T* instance, void (T::*cb)(const ::Murmur::NameMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerUpdatingAuthenticator_getRegisteredUsers<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerUpdatingAuthenticator_getRegisteredUsers : public Callback_ServerUpdatingAuthenticator_getRegisteredUsers_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::NameMap&, const CT&);

    Callback_ServerUpdatingAuthenticator_getRegisteredUsers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerUpdatingAuthenticatorPrx __proxy = ::Murmur::ServerUpdatingAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Murmur::NameMap __ret;
        try
        {
            __ret = __proxy->end_getRegisteredUsers(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerUpdatingAuthenticator_getRegisteredUsersPtr
newCallback_ServerUpdatingAuthenticator_getRegisteredUsers(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::NameMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerUpdatingAuthenticator_getRegisteredUsers<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerUpdatingAuthenticator_getRegisteredUsersPtr
newCallback_ServerUpdatingAuthenticator_getRegisteredUsers(T* instance, void (T::*cb)(const ::Murmur::NameMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerUpdatingAuthenticator_getRegisteredUsers<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerUpdatingAuthenticator_setInfo : public Callback_ServerUpdatingAuthenticator_setInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_ServerUpdatingAuthenticator_setInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerUpdatingAuthenticatorPrx __proxy = ::Murmur::ServerUpdatingAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_setInfo(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerUpdatingAuthenticator_setInfoPtr
newCallback_ServerUpdatingAuthenticator_setInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerUpdatingAuthenticator_setInfo<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerUpdatingAuthenticator_setInfoPtr
newCallback_ServerUpdatingAuthenticator_setInfo(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerUpdatingAuthenticator_setInfo<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerUpdatingAuthenticator_setInfo : public Callback_ServerUpdatingAuthenticator_setInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_ServerUpdatingAuthenticator_setInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerUpdatingAuthenticatorPrx __proxy = ::Murmur::ServerUpdatingAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_setInfo(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerUpdatingAuthenticator_setInfoPtr
newCallback_ServerUpdatingAuthenticator_setInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerUpdatingAuthenticator_setInfo<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerUpdatingAuthenticator_setInfoPtr
newCallback_ServerUpdatingAuthenticator_setInfo(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerUpdatingAuthenticator_setInfo<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerUpdatingAuthenticator_setTexture : public Callback_ServerUpdatingAuthenticator_setTexture_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_ServerUpdatingAuthenticator_setTexture(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerUpdatingAuthenticatorPrx __proxy = ::Murmur::ServerUpdatingAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_setTexture(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerUpdatingAuthenticator_setTexturePtr
newCallback_ServerUpdatingAuthenticator_setTexture(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerUpdatingAuthenticator_setTexture<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerUpdatingAuthenticator_setTexturePtr
newCallback_ServerUpdatingAuthenticator_setTexture(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerUpdatingAuthenticator_setTexture<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerUpdatingAuthenticator_setTexture : public Callback_ServerUpdatingAuthenticator_setTexture_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_ServerUpdatingAuthenticator_setTexture(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerUpdatingAuthenticatorPrx __proxy = ::Murmur::ServerUpdatingAuthenticatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_setTexture(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerUpdatingAuthenticator_setTexturePtr
newCallback_ServerUpdatingAuthenticator_setTexture(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerUpdatingAuthenticator_setTexture<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerUpdatingAuthenticator_setTexturePtr
newCallback_ServerUpdatingAuthenticator_setTexture(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerUpdatingAuthenticator_setTexture<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_isRunning : public Callback_Server_isRunning_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Server_isRunning(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isRunning(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_isRunningPtr
newCallback_Server_isRunning(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_isRunning<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_isRunningPtr
newCallback_Server_isRunning(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_isRunning<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_isRunning : public Callback_Server_isRunning_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Server_isRunning(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isRunning(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_isRunningPtr
newCallback_Server_isRunning(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_isRunning<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_isRunningPtr
newCallback_Server_isRunning(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_isRunning<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_start : public Callback_Server_start_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_start(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_start(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_startPtr
newCallback_Server_start(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_start<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_startPtr
newCallback_Server_start(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_start<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_startPtr
newCallback_Server_start(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_start<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_startPtr
newCallback_Server_start(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_start<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_start : public Callback_Server_start_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_start(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_start(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_startPtr
newCallback_Server_start(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_start<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_startPtr
newCallback_Server_start(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_start<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_startPtr
newCallback_Server_start(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_start<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_startPtr
newCallback_Server_start(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_start<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_stop : public Callback_Server_stop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_stop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_stop(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_stopPtr
newCallback_Server_stop(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_stop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_stopPtr
newCallback_Server_stop(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_stop<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_stopPtr
newCallback_Server_stop(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_stop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_stopPtr
newCallback_Server_stop(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_stop<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_stop : public Callback_Server_stop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_stop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_stop(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_stopPtr
newCallback_Server_stop(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_stop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_stopPtr
newCallback_Server_stop(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_stop<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_stopPtr
newCallback_Server_stop(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_stop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_stopPtr
newCallback_Server_stop(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_stop<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_delete : public Callback_Server_delete_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_delete(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_delete(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_deletePtr
newCallback_Server_delete(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_delete<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_deletePtr
newCallback_Server_delete(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_delete<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_deletePtr
newCallback_Server_delete(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_delete<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_deletePtr
newCallback_Server_delete(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_delete<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_delete : public Callback_Server_delete_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_delete(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_delete(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_deletePtr
newCallback_Server_delete(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_delete<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_deletePtr
newCallback_Server_delete(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_delete<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_deletePtr
newCallback_Server_delete(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_delete<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_deletePtr
newCallback_Server_delete(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_delete<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_id : public Callback_Server_id_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Server_id(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_id(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_idPtr
newCallback_Server_id(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_id<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_idPtr
newCallback_Server_id(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_id<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_id : public Callback_Server_id_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Server_id(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_id(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_idPtr
newCallback_Server_id(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_id<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_idPtr
newCallback_Server_id(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_id<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_addCallback : public Callback_Server_addCallback_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_addCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addCallback(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_addCallbackPtr
newCallback_Server_addCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_addCallback<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_addCallbackPtr
newCallback_Server_addCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_addCallback<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_addCallbackPtr
newCallback_Server_addCallback(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_addCallback<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_addCallbackPtr
newCallback_Server_addCallback(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_addCallback<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_addCallback : public Callback_Server_addCallback_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_addCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addCallback(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_addCallbackPtr
newCallback_Server_addCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_addCallback<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_addCallbackPtr
newCallback_Server_addCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_addCallback<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_addCallbackPtr
newCallback_Server_addCallback(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_addCallback<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_addCallbackPtr
newCallback_Server_addCallback(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_addCallback<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_removeCallback : public Callback_Server_removeCallback_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_removeCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_removeCallback(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_removeCallbackPtr
newCallback_Server_removeCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeCallback<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_removeCallbackPtr
newCallback_Server_removeCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeCallback<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_removeCallbackPtr
newCallback_Server_removeCallback(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeCallback<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_removeCallbackPtr
newCallback_Server_removeCallback(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeCallback<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_removeCallback : public Callback_Server_removeCallback_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_removeCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_removeCallback(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_removeCallbackPtr
newCallback_Server_removeCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeCallback<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_removeCallbackPtr
newCallback_Server_removeCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeCallback<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_removeCallbackPtr
newCallback_Server_removeCallback(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeCallback<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_removeCallbackPtr
newCallback_Server_removeCallback(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeCallback<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_setAuthenticator : public Callback_Server_setAuthenticator_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_setAuthenticator(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setAuthenticator(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_setAuthenticatorPtr
newCallback_Server_setAuthenticator(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setAuthenticator<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setAuthenticatorPtr
newCallback_Server_setAuthenticator(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setAuthenticator<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_setAuthenticatorPtr
newCallback_Server_setAuthenticator(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setAuthenticator<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setAuthenticatorPtr
newCallback_Server_setAuthenticator(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setAuthenticator<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_setAuthenticator : public Callback_Server_setAuthenticator_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_setAuthenticator(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setAuthenticator(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_setAuthenticatorPtr
newCallback_Server_setAuthenticator(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setAuthenticator<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setAuthenticatorPtr
newCallback_Server_setAuthenticator(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setAuthenticator<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setAuthenticatorPtr
newCallback_Server_setAuthenticator(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setAuthenticator<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setAuthenticatorPtr
newCallback_Server_setAuthenticator(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setAuthenticator<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getConf : public Callback_Server_getConf_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Server_getConf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getConf(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getConfPtr
newCallback_Server_getConf(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getConf<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getConfPtr
newCallback_Server_getConf(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getConf<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getConf : public Callback_Server_getConf_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Server_getConf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getConf(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getConfPtr
newCallback_Server_getConf(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getConf<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getConfPtr
newCallback_Server_getConf(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getConf<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getAllConf : public Callback_Server_getAllConf_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::ConfigMap&);

    CallbackNC_Server_getAllConf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ConfigMap __ret;
        try
        {
            __ret = __proxy->end_getAllConf(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getAllConfPtr
newCallback_Server_getAllConf(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ConfigMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getAllConf<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getAllConfPtr
newCallback_Server_getAllConf(T* instance, void (T::*cb)(const ::Murmur::ConfigMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getAllConf<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getAllConf : public Callback_Server_getAllConf_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::ConfigMap&, const CT&);

    Callback_Server_getAllConf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ConfigMap __ret;
        try
        {
            __ret = __proxy->end_getAllConf(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getAllConfPtr
newCallback_Server_getAllConf(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ConfigMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getAllConf<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getAllConfPtr
newCallback_Server_getAllConf(T* instance, void (T::*cb)(const ::Murmur::ConfigMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getAllConf<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_setConf : public Callback_Server_setConf_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_setConf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setConf(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_setConfPtr
newCallback_Server_setConf(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setConf<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setConfPtr
newCallback_Server_setConf(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setConf<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_setConfPtr
newCallback_Server_setConf(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setConf<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setConfPtr
newCallback_Server_setConf(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setConf<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_setConf : public Callback_Server_setConf_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_setConf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setConf(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_setConfPtr
newCallback_Server_setConf(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setConf<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setConfPtr
newCallback_Server_setConf(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setConf<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setConfPtr
newCallback_Server_setConf(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setConf<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setConfPtr
newCallback_Server_setConf(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setConf<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_setSuperuserPassword : public Callback_Server_setSuperuserPassword_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_setSuperuserPassword(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setSuperuserPassword(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_setSuperuserPasswordPtr
newCallback_Server_setSuperuserPassword(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setSuperuserPassword<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setSuperuserPasswordPtr
newCallback_Server_setSuperuserPassword(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setSuperuserPassword<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_setSuperuserPasswordPtr
newCallback_Server_setSuperuserPassword(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setSuperuserPassword<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setSuperuserPasswordPtr
newCallback_Server_setSuperuserPassword(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setSuperuserPassword<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_setSuperuserPassword : public Callback_Server_setSuperuserPassword_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_setSuperuserPassword(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setSuperuserPassword(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_setSuperuserPasswordPtr
newCallback_Server_setSuperuserPassword(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setSuperuserPassword<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setSuperuserPasswordPtr
newCallback_Server_setSuperuserPassword(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setSuperuserPassword<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setSuperuserPasswordPtr
newCallback_Server_setSuperuserPassword(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setSuperuserPassword<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setSuperuserPasswordPtr
newCallback_Server_setSuperuserPassword(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setSuperuserPassword<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getLog : public Callback_Server_getLog_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::LogList&);

    CallbackNC_Server_getLog(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::LogList __ret;
        try
        {
            __ret = __proxy->end_getLog(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getLogPtr
newCallback_Server_getLog(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::LogList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getLog<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getLogPtr
newCallback_Server_getLog(T* instance, void (T::*cb)(const ::Murmur::LogList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getLog<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getLog : public Callback_Server_getLog_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::LogList&, const CT&);

    Callback_Server_getLog(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::LogList __ret;
        try
        {
            __ret = __proxy->end_getLog(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getLogPtr
newCallback_Server_getLog(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::LogList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getLog<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getLogPtr
newCallback_Server_getLog(T* instance, void (T::*cb)(const ::Murmur::LogList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getLog<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getLogLen : public Callback_Server_getLogLen_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Server_getLogLen(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getLogLen(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getLogLenPtr
newCallback_Server_getLogLen(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getLogLen<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getLogLenPtr
newCallback_Server_getLogLen(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getLogLen<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getLogLen : public Callback_Server_getLogLen_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Server_getLogLen(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getLogLen(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getLogLenPtr
newCallback_Server_getLogLen(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getLogLen<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getLogLenPtr
newCallback_Server_getLogLen(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getLogLen<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getUsers : public Callback_Server_getUsers_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::UserMap&);

    CallbackNC_Server_getUsers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::UserMap __ret;
        try
        {
            __ret = __proxy->end_getUsers(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getUsersPtr
newCallback_Server_getUsers(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::UserMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getUsers<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getUsersPtr
newCallback_Server_getUsers(T* instance, void (T::*cb)(const ::Murmur::UserMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getUsers<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getUsers : public Callback_Server_getUsers_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::UserMap&, const CT&);

    Callback_Server_getUsers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::UserMap __ret;
        try
        {
            __ret = __proxy->end_getUsers(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getUsersPtr
newCallback_Server_getUsers(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::UserMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getUsers<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getUsersPtr
newCallback_Server_getUsers(T* instance, void (T::*cb)(const ::Murmur::UserMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getUsers<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getChannels : public Callback_Server_getChannels_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::ChannelMap&);

    CallbackNC_Server_getChannels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ChannelMap __ret;
        try
        {
            __ret = __proxy->end_getChannels(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getChannelsPtr
newCallback_Server_getChannels(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ChannelMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getChannels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getChannelsPtr
newCallback_Server_getChannels(T* instance, void (T::*cb)(const ::Murmur::ChannelMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getChannels<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getChannels : public Callback_Server_getChannels_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::ChannelMap&, const CT&);

    Callback_Server_getChannels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ChannelMap __ret;
        try
        {
            __ret = __proxy->end_getChannels(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getChannelsPtr
newCallback_Server_getChannels(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ChannelMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getChannels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getChannelsPtr
newCallback_Server_getChannels(T* instance, void (T::*cb)(const ::Murmur::ChannelMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getChannels<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getCertificateList : public Callback_Server_getCertificateList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::CertificateList&);

    CallbackNC_Server_getCertificateList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::CertificateList __ret;
        try
        {
            __ret = __proxy->end_getCertificateList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getCertificateListPtr
newCallback_Server_getCertificateList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::CertificateList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getCertificateList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getCertificateListPtr
newCallback_Server_getCertificateList(T* instance, void (T::*cb)(const ::Murmur::CertificateList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getCertificateList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getCertificateList : public Callback_Server_getCertificateList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::CertificateList&, const CT&);

    Callback_Server_getCertificateList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::CertificateList __ret;
        try
        {
            __ret = __proxy->end_getCertificateList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getCertificateListPtr
newCallback_Server_getCertificateList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::CertificateList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getCertificateList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getCertificateListPtr
newCallback_Server_getCertificateList(T* instance, void (T::*cb)(const ::Murmur::CertificateList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getCertificateList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getTree : public Callback_Server_getTree_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::TreePtr&);

    CallbackNC_Server_getTree(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::TreePtr __ret;
        try
        {
            __ret = __proxy->end_getTree(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getTreePtr
newCallback_Server_getTree(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::TreePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getTree<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getTreePtr
newCallback_Server_getTree(T* instance, void (T::*cb)(const ::Murmur::TreePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getTree<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getTree : public Callback_Server_getTree_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::TreePtr&, const CT&);

    Callback_Server_getTree(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::TreePtr __ret;
        try
        {
            __ret = __proxy->end_getTree(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getTreePtr
newCallback_Server_getTree(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::TreePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getTree<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getTreePtr
newCallback_Server_getTree(T* instance, void (T::*cb)(const ::Murmur::TreePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getTree<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getBans : public Callback_Server_getBans_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::BanList&);

    CallbackNC_Server_getBans(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::BanList __ret;
        try
        {
            __ret = __proxy->end_getBans(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getBansPtr
newCallback_Server_getBans(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::BanList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getBans<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getBansPtr
newCallback_Server_getBans(T* instance, void (T::*cb)(const ::Murmur::BanList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getBans<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getBans : public Callback_Server_getBans_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::BanList&, const CT&);

    Callback_Server_getBans(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::BanList __ret;
        try
        {
            __ret = __proxy->end_getBans(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getBansPtr
newCallback_Server_getBans(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::BanList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getBans<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getBansPtr
newCallback_Server_getBans(T* instance, void (T::*cb)(const ::Murmur::BanList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getBans<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_setBans : public Callback_Server_setBans_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_setBans(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setBans(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_setBansPtr
newCallback_Server_setBans(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setBans<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setBansPtr
newCallback_Server_setBans(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setBans<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_setBansPtr
newCallback_Server_setBans(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setBans<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setBansPtr
newCallback_Server_setBans(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setBans<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_setBans : public Callback_Server_setBans_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_setBans(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setBans(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_setBansPtr
newCallback_Server_setBans(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setBans<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setBansPtr
newCallback_Server_setBans(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setBans<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setBansPtr
newCallback_Server_setBans(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setBans<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setBansPtr
newCallback_Server_setBans(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setBans<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_kickUser : public Callback_Server_kickUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_kickUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_kickUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_kickUserPtr
newCallback_Server_kickUser(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_kickUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_kickUserPtr
newCallback_Server_kickUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_kickUser<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_kickUserPtr
newCallback_Server_kickUser(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_kickUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_kickUserPtr
newCallback_Server_kickUser(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_kickUser<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_kickUser : public Callback_Server_kickUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_kickUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_kickUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_kickUserPtr
newCallback_Server_kickUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_kickUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_kickUserPtr
newCallback_Server_kickUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_kickUser<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_kickUserPtr
newCallback_Server_kickUser(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_kickUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_kickUserPtr
newCallback_Server_kickUser(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_kickUser<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getState : public Callback_Server_getState_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::User&);

    CallbackNC_Server_getState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::User __ret;
        try
        {
            __ret = __proxy->end_getState(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getStatePtr
newCallback_Server_getState(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::User&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getState<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getStatePtr
newCallback_Server_getState(T* instance, void (T::*cb)(const ::Murmur::User&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getState<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getState : public Callback_Server_getState_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::User&, const CT&);

    Callback_Server_getState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::User __ret;
        try
        {
            __ret = __proxy->end_getState(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getStatePtr
newCallback_Server_getState(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::User&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getState<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getStatePtr
newCallback_Server_getState(T* instance, void (T::*cb)(const ::Murmur::User&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getState<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_setState : public Callback_Server_setState_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_setState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setState(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_setStatePtr
newCallback_Server_setState(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setState<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setStatePtr
newCallback_Server_setState(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setState<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_setStatePtr
newCallback_Server_setState(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setState<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setStatePtr
newCallback_Server_setState(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setState<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_setState : public Callback_Server_setState_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_setState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setState(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_setStatePtr
newCallback_Server_setState(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setState<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setStatePtr
newCallback_Server_setState(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setState<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setStatePtr
newCallback_Server_setState(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setState<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setStatePtr
newCallback_Server_setState(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setState<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_sendMessage : public Callback_Server_sendMessage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_sendMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_sendMessage(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_sendMessagePtr
newCallback_Server_sendMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_sendMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_sendMessagePtr
newCallback_Server_sendMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_sendMessage<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_sendMessagePtr
newCallback_Server_sendMessage(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_sendMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_sendMessagePtr
newCallback_Server_sendMessage(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_sendMessage<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_sendMessage : public Callback_Server_sendMessage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_sendMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_sendMessage(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_sendMessagePtr
newCallback_Server_sendMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_sendMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_sendMessagePtr
newCallback_Server_sendMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_sendMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_sendMessagePtr
newCallback_Server_sendMessage(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_sendMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_sendMessagePtr
newCallback_Server_sendMessage(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_sendMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_hasPermission : public Callback_Server_hasPermission_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Server_hasPermission(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_hasPermission(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_hasPermissionPtr
newCallback_Server_hasPermission(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_hasPermission<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_hasPermissionPtr
newCallback_Server_hasPermission(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_hasPermission<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_hasPermission : public Callback_Server_hasPermission_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Server_hasPermission(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_hasPermission(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_hasPermissionPtr
newCallback_Server_hasPermission(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_hasPermission<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_hasPermissionPtr
newCallback_Server_hasPermission(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_hasPermission<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_addContextCallback : public Callback_Server_addContextCallback_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_addContextCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addContextCallback(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_addContextCallbackPtr
newCallback_Server_addContextCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_addContextCallback<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_addContextCallbackPtr
newCallback_Server_addContextCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_addContextCallback<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_addContextCallbackPtr
newCallback_Server_addContextCallback(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_addContextCallback<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_addContextCallbackPtr
newCallback_Server_addContextCallback(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_addContextCallback<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_addContextCallback : public Callback_Server_addContextCallback_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_addContextCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addContextCallback(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_addContextCallbackPtr
newCallback_Server_addContextCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_addContextCallback<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_addContextCallbackPtr
newCallback_Server_addContextCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_addContextCallback<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_addContextCallbackPtr
newCallback_Server_addContextCallback(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_addContextCallback<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_addContextCallbackPtr
newCallback_Server_addContextCallback(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_addContextCallback<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_removeContextCallback : public Callback_Server_removeContextCallback_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_removeContextCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_removeContextCallback(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_removeContextCallbackPtr
newCallback_Server_removeContextCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeContextCallback<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_removeContextCallbackPtr
newCallback_Server_removeContextCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeContextCallback<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_removeContextCallbackPtr
newCallback_Server_removeContextCallback(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeContextCallback<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_removeContextCallbackPtr
newCallback_Server_removeContextCallback(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeContextCallback<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_removeContextCallback : public Callback_Server_removeContextCallback_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_removeContextCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_removeContextCallback(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_removeContextCallbackPtr
newCallback_Server_removeContextCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeContextCallback<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_removeContextCallbackPtr
newCallback_Server_removeContextCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeContextCallback<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_removeContextCallbackPtr
newCallback_Server_removeContextCallback(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeContextCallback<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_removeContextCallbackPtr
newCallback_Server_removeContextCallback(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeContextCallback<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getChannelState : public Callback_Server_getChannelState_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::Channel&);

    CallbackNC_Server_getChannelState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::Channel __ret;
        try
        {
            __ret = __proxy->end_getChannelState(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getChannelStatePtr
newCallback_Server_getChannelState(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::Channel&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getChannelState<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getChannelStatePtr
newCallback_Server_getChannelState(T* instance, void (T::*cb)(const ::Murmur::Channel&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getChannelState<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getChannelState : public Callback_Server_getChannelState_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::Channel&, const CT&);

    Callback_Server_getChannelState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::Channel __ret;
        try
        {
            __ret = __proxy->end_getChannelState(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getChannelStatePtr
newCallback_Server_getChannelState(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::Channel&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getChannelState<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getChannelStatePtr
newCallback_Server_getChannelState(T* instance, void (T::*cb)(const ::Murmur::Channel&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getChannelState<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_setChannelState : public Callback_Server_setChannelState_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_setChannelState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setChannelState(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_setChannelStatePtr
newCallback_Server_setChannelState(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setChannelState<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setChannelStatePtr
newCallback_Server_setChannelState(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setChannelState<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_setChannelStatePtr
newCallback_Server_setChannelState(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setChannelState<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setChannelStatePtr
newCallback_Server_setChannelState(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setChannelState<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_setChannelState : public Callback_Server_setChannelState_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_setChannelState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setChannelState(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_setChannelStatePtr
newCallback_Server_setChannelState(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setChannelState<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setChannelStatePtr
newCallback_Server_setChannelState(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setChannelState<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setChannelStatePtr
newCallback_Server_setChannelState(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setChannelState<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setChannelStatePtr
newCallback_Server_setChannelState(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setChannelState<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_removeChannel : public Callback_Server_removeChannel_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_removeChannel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_removeChannel(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_removeChannelPtr
newCallback_Server_removeChannel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeChannel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_removeChannelPtr
newCallback_Server_removeChannel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeChannel<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_removeChannelPtr
newCallback_Server_removeChannel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeChannel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_removeChannelPtr
newCallback_Server_removeChannel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeChannel<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_removeChannel : public Callback_Server_removeChannel_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_removeChannel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_removeChannel(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_removeChannelPtr
newCallback_Server_removeChannel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeChannel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_removeChannelPtr
newCallback_Server_removeChannel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeChannel<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_removeChannelPtr
newCallback_Server_removeChannel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeChannel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_removeChannelPtr
newCallback_Server_removeChannel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeChannel<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_addChannel : public Callback_Server_addChannel_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Server_addChannel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_addChannel(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_addChannelPtr
newCallback_Server_addChannel(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_addChannel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_addChannelPtr
newCallback_Server_addChannel(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_addChannel<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_addChannel : public Callback_Server_addChannel_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Server_addChannel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_addChannel(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_addChannelPtr
newCallback_Server_addChannel(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_addChannel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_addChannelPtr
newCallback_Server_addChannel(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_addChannel<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_sendMessageChannel : public Callback_Server_sendMessageChannel_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_sendMessageChannel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_sendMessageChannel(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_sendMessageChannelPtr
newCallback_Server_sendMessageChannel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_sendMessageChannel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_sendMessageChannelPtr
newCallback_Server_sendMessageChannel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_sendMessageChannel<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_sendMessageChannelPtr
newCallback_Server_sendMessageChannel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_sendMessageChannel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_sendMessageChannelPtr
newCallback_Server_sendMessageChannel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_sendMessageChannel<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_sendMessageChannel : public Callback_Server_sendMessageChannel_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_sendMessageChannel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_sendMessageChannel(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_sendMessageChannelPtr
newCallback_Server_sendMessageChannel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_sendMessageChannel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_sendMessageChannelPtr
newCallback_Server_sendMessageChannel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_sendMessageChannel<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_sendMessageChannelPtr
newCallback_Server_sendMessageChannel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_sendMessageChannel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_sendMessageChannelPtr
newCallback_Server_sendMessageChannel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_sendMessageChannel<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getACL : public Callback_Server_getACL_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool);

    CallbackNC_Server_getACL(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ACLList acls;
        ::Murmur::GroupList groups;
        bool inherit;
        try
        {
            __proxy->end_getACL(acls, groups, inherit, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(acls, groups, inherit);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(acls, groups, inherit);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getACLPtr
newCallback_Server_getACL(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getACL<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getACLPtr
newCallback_Server_getACL(T* instance, void (T::*cb)(const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getACL<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getACL : public Callback_Server_getACL_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool, const CT&);

    Callback_Server_getACL(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ACLList acls;
        ::Murmur::GroupList groups;
        bool inherit;
        try
        {
            __proxy->end_getACL(acls, groups, inherit, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(acls, groups, inherit, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(acls, groups, inherit, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getACLPtr
newCallback_Server_getACL(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getACL<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getACLPtr
newCallback_Server_getACL(T* instance, void (T::*cb)(const ::Murmur::ACLList&, const ::Murmur::GroupList&, bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getACL<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_setACL : public Callback_Server_setACL_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_setACL(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setACL(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_setACLPtr
newCallback_Server_setACL(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setACL<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setACLPtr
newCallback_Server_setACL(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setACL<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_setACLPtr
newCallback_Server_setACL(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setACL<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setACLPtr
newCallback_Server_setACL(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setACL<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_setACL : public Callback_Server_setACL_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_setACL(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setACL(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_setACLPtr
newCallback_Server_setACL(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setACL<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setACLPtr
newCallback_Server_setACL(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setACL<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setACLPtr
newCallback_Server_setACL(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setACL<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setACLPtr
newCallback_Server_setACL(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setACL<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_addUserToGroup : public Callback_Server_addUserToGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_addUserToGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addUserToGroup(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_addUserToGroupPtr
newCallback_Server_addUserToGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_addUserToGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_addUserToGroupPtr
newCallback_Server_addUserToGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_addUserToGroup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_addUserToGroupPtr
newCallback_Server_addUserToGroup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_addUserToGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_addUserToGroupPtr
newCallback_Server_addUserToGroup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_addUserToGroup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_addUserToGroup : public Callback_Server_addUserToGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_addUserToGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addUserToGroup(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_addUserToGroupPtr
newCallback_Server_addUserToGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_addUserToGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_addUserToGroupPtr
newCallback_Server_addUserToGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_addUserToGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_addUserToGroupPtr
newCallback_Server_addUserToGroup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_addUserToGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_addUserToGroupPtr
newCallback_Server_addUserToGroup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_addUserToGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_removeUserFromGroup : public Callback_Server_removeUserFromGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_removeUserFromGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_removeUserFromGroup(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_removeUserFromGroupPtr
newCallback_Server_removeUserFromGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeUserFromGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_removeUserFromGroupPtr
newCallback_Server_removeUserFromGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeUserFromGroup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_removeUserFromGroupPtr
newCallback_Server_removeUserFromGroup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeUserFromGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_removeUserFromGroupPtr
newCallback_Server_removeUserFromGroup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_removeUserFromGroup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_removeUserFromGroup : public Callback_Server_removeUserFromGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_removeUserFromGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_removeUserFromGroup(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_removeUserFromGroupPtr
newCallback_Server_removeUserFromGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeUserFromGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_removeUserFromGroupPtr
newCallback_Server_removeUserFromGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeUserFromGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_removeUserFromGroupPtr
newCallback_Server_removeUserFromGroup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeUserFromGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_removeUserFromGroupPtr
newCallback_Server_removeUserFromGroup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_removeUserFromGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_redirectWhisperGroup : public Callback_Server_redirectWhisperGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_redirectWhisperGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_redirectWhisperGroup(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_redirectWhisperGroupPtr
newCallback_Server_redirectWhisperGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_redirectWhisperGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_redirectWhisperGroupPtr
newCallback_Server_redirectWhisperGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_redirectWhisperGroup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_redirectWhisperGroupPtr
newCallback_Server_redirectWhisperGroup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_redirectWhisperGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_redirectWhisperGroupPtr
newCallback_Server_redirectWhisperGroup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_redirectWhisperGroup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_redirectWhisperGroup : public Callback_Server_redirectWhisperGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_redirectWhisperGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_redirectWhisperGroup(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_redirectWhisperGroupPtr
newCallback_Server_redirectWhisperGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_redirectWhisperGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_redirectWhisperGroupPtr
newCallback_Server_redirectWhisperGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_redirectWhisperGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_redirectWhisperGroupPtr
newCallback_Server_redirectWhisperGroup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_redirectWhisperGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_redirectWhisperGroupPtr
newCallback_Server_redirectWhisperGroup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_redirectWhisperGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getUserNames : public Callback_Server_getUserNames_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::NameMap&);

    CallbackNC_Server_getUserNames(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::NameMap __ret;
        try
        {
            __ret = __proxy->end_getUserNames(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getUserNamesPtr
newCallback_Server_getUserNames(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::NameMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getUserNames<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getUserNamesPtr
newCallback_Server_getUserNames(T* instance, void (T::*cb)(const ::Murmur::NameMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getUserNames<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getUserNames : public Callback_Server_getUserNames_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::NameMap&, const CT&);

    Callback_Server_getUserNames(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::NameMap __ret;
        try
        {
            __ret = __proxy->end_getUserNames(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getUserNamesPtr
newCallback_Server_getUserNames(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::NameMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getUserNames<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getUserNamesPtr
newCallback_Server_getUserNames(T* instance, void (T::*cb)(const ::Murmur::NameMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getUserNames<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getUserIds : public Callback_Server_getUserIds_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::IdMap&);

    CallbackNC_Server_getUserIds(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::IdMap __ret;
        try
        {
            __ret = __proxy->end_getUserIds(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getUserIdsPtr
newCallback_Server_getUserIds(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::IdMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getUserIds<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getUserIdsPtr
newCallback_Server_getUserIds(T* instance, void (T::*cb)(const ::Murmur::IdMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getUserIds<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getUserIds : public Callback_Server_getUserIds_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::IdMap&, const CT&);

    Callback_Server_getUserIds(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::IdMap __ret;
        try
        {
            __ret = __proxy->end_getUserIds(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getUserIdsPtr
newCallback_Server_getUserIds(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::IdMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getUserIds<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getUserIdsPtr
newCallback_Server_getUserIds(T* instance, void (T::*cb)(const ::Murmur::IdMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getUserIds<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_registerUser : public Callback_Server_registerUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Server_registerUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_registerUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_registerUserPtr
newCallback_Server_registerUser(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_registerUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_registerUserPtr
newCallback_Server_registerUser(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_registerUser<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_registerUser : public Callback_Server_registerUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Server_registerUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_registerUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_registerUserPtr
newCallback_Server_registerUser(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_registerUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_registerUserPtr
newCallback_Server_registerUser(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_registerUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_unregisterUser : public Callback_Server_unregisterUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_unregisterUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_unregisterUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_unregisterUserPtr
newCallback_Server_unregisterUser(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_unregisterUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_unregisterUserPtr
newCallback_Server_unregisterUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_unregisterUser<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_unregisterUserPtr
newCallback_Server_unregisterUser(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_unregisterUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_unregisterUserPtr
newCallback_Server_unregisterUser(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_unregisterUser<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_unregisterUser : public Callback_Server_unregisterUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_unregisterUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_unregisterUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_unregisterUserPtr
newCallback_Server_unregisterUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_unregisterUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_unregisterUserPtr
newCallback_Server_unregisterUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_unregisterUser<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_unregisterUserPtr
newCallback_Server_unregisterUser(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_unregisterUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_unregisterUserPtr
newCallback_Server_unregisterUser(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_unregisterUser<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_updateRegistration : public Callback_Server_updateRegistration_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_updateRegistration(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_updateRegistration(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_updateRegistrationPtr
newCallback_Server_updateRegistration(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_updateRegistration<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_updateRegistrationPtr
newCallback_Server_updateRegistration(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_updateRegistration<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_updateRegistrationPtr
newCallback_Server_updateRegistration(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_updateRegistration<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_updateRegistrationPtr
newCallback_Server_updateRegistration(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_updateRegistration<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_updateRegistration : public Callback_Server_updateRegistration_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_updateRegistration(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_updateRegistration(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_updateRegistrationPtr
newCallback_Server_updateRegistration(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_updateRegistration<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_updateRegistrationPtr
newCallback_Server_updateRegistration(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_updateRegistration<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_updateRegistrationPtr
newCallback_Server_updateRegistration(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_updateRegistration<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_updateRegistrationPtr
newCallback_Server_updateRegistration(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_updateRegistration<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getRegistration : public Callback_Server_getRegistration_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::UserInfoMap&);

    CallbackNC_Server_getRegistration(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::UserInfoMap __ret;
        try
        {
            __ret = __proxy->end_getRegistration(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getRegistrationPtr
newCallback_Server_getRegistration(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::UserInfoMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getRegistration<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getRegistrationPtr
newCallback_Server_getRegistration(T* instance, void (T::*cb)(const ::Murmur::UserInfoMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getRegistration<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getRegistration : public Callback_Server_getRegistration_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::UserInfoMap&, const CT&);

    Callback_Server_getRegistration(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::UserInfoMap __ret;
        try
        {
            __ret = __proxy->end_getRegistration(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getRegistrationPtr
newCallback_Server_getRegistration(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::UserInfoMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getRegistration<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getRegistrationPtr
newCallback_Server_getRegistration(T* instance, void (T::*cb)(const ::Murmur::UserInfoMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getRegistration<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getRegisteredUsers : public Callback_Server_getRegisteredUsers_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::NameMap&);

    CallbackNC_Server_getRegisteredUsers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::NameMap __ret;
        try
        {
            __ret = __proxy->end_getRegisteredUsers(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getRegisteredUsersPtr
newCallback_Server_getRegisteredUsers(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::NameMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getRegisteredUsers<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getRegisteredUsersPtr
newCallback_Server_getRegisteredUsers(T* instance, void (T::*cb)(const ::Murmur::NameMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getRegisteredUsers<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getRegisteredUsers : public Callback_Server_getRegisteredUsers_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::NameMap&, const CT&);

    Callback_Server_getRegisteredUsers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::NameMap __ret;
        try
        {
            __ret = __proxy->end_getRegisteredUsers(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getRegisteredUsersPtr
newCallback_Server_getRegisteredUsers(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::NameMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getRegisteredUsers<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getRegisteredUsersPtr
newCallback_Server_getRegisteredUsers(T* instance, void (T::*cb)(const ::Murmur::NameMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getRegisteredUsers<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_verifyPassword : public Callback_Server_verifyPassword_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Server_verifyPassword(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_verifyPassword(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_verifyPasswordPtr
newCallback_Server_verifyPassword(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_verifyPassword<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_verifyPasswordPtr
newCallback_Server_verifyPassword(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_verifyPassword<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_verifyPassword : public Callback_Server_verifyPassword_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Server_verifyPassword(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_verifyPassword(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_verifyPasswordPtr
newCallback_Server_verifyPassword(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_verifyPassword<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_verifyPasswordPtr
newCallback_Server_verifyPassword(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_verifyPassword<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getTexture : public Callback_Server_getTexture_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::Texture&);

    CallbackNC_Server_getTexture(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::Texture __ret;
        try
        {
            __ret = __proxy->end_getTexture(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getTexturePtr
newCallback_Server_getTexture(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::Texture&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getTexture<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getTexturePtr
newCallback_Server_getTexture(T* instance, void (T::*cb)(const ::Murmur::Texture&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getTexture<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getTexture : public Callback_Server_getTexture_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::Texture&, const CT&);

    Callback_Server_getTexture(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Murmur::Texture __ret;
        try
        {
            __ret = __proxy->end_getTexture(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getTexturePtr
newCallback_Server_getTexture(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::Texture&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getTexture<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getTexturePtr
newCallback_Server_getTexture(T* instance, void (T::*cb)(const ::Murmur::Texture&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getTexture<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_setTexture : public Callback_Server_setTexture_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_setTexture(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setTexture(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_setTexturePtr
newCallback_Server_setTexture(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setTexture<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setTexturePtr
newCallback_Server_setTexture(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setTexture<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_setTexturePtr
newCallback_Server_setTexture(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setTexture<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_setTexturePtr
newCallback_Server_setTexture(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_setTexture<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_setTexture : public Callback_Server_setTexture_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_setTexture(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setTexture(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_setTexturePtr
newCallback_Server_setTexture(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setTexture<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setTexturePtr
newCallback_Server_setTexture(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setTexture<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setTexturePtr
newCallback_Server_setTexture(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setTexture<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_setTexturePtr
newCallback_Server_setTexture(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_setTexture<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getUptime : public Callback_Server_getUptime_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Server_getUptime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getUptime(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Server_getUptimePtr
newCallback_Server_getUptime(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getUptime<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getUptimePtr
newCallback_Server_getUptime(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getUptime<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getUptime : public Callback_Server_getUptime_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Server_getUptime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::ServerPrx __proxy = ::Murmur::ServerPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getUptime(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Server_getUptimePtr
newCallback_Server_getUptime(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getUptime<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getUptimePtr
newCallback_Server_getUptime(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getUptime<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MetaCallback_started : public Callback_MetaCallback_started_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MetaCallback_started(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MetaCallback_startedPtr
newCallback_MetaCallback_started(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MetaCallback_started<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MetaCallback_startedPtr
newCallback_MetaCallback_started(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MetaCallback_started<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MetaCallback_startedPtr
newCallback_MetaCallback_started(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MetaCallback_started<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MetaCallback_startedPtr
newCallback_MetaCallback_started(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MetaCallback_started<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MetaCallback_started : public Callback_MetaCallback_started_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MetaCallback_started(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MetaCallback_startedPtr
newCallback_MetaCallback_started(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MetaCallback_started<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MetaCallback_startedPtr
newCallback_MetaCallback_started(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MetaCallback_started<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MetaCallback_startedPtr
newCallback_MetaCallback_started(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MetaCallback_started<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MetaCallback_startedPtr
newCallback_MetaCallback_started(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MetaCallback_started<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MetaCallback_stopped : public Callback_MetaCallback_stopped_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MetaCallback_stopped(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MetaCallback_stoppedPtr
newCallback_MetaCallback_stopped(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MetaCallback_stopped<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MetaCallback_stoppedPtr
newCallback_MetaCallback_stopped(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MetaCallback_stopped<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MetaCallback_stoppedPtr
newCallback_MetaCallback_stopped(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MetaCallback_stopped<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MetaCallback_stoppedPtr
newCallback_MetaCallback_stopped(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MetaCallback_stopped<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MetaCallback_stopped : public Callback_MetaCallback_stopped_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MetaCallback_stopped(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MetaCallback_stoppedPtr
newCallback_MetaCallback_stopped(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MetaCallback_stopped<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MetaCallback_stoppedPtr
newCallback_MetaCallback_stopped(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MetaCallback_stopped<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MetaCallback_stoppedPtr
newCallback_MetaCallback_stopped(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MetaCallback_stopped<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MetaCallback_stoppedPtr
newCallback_MetaCallback_stopped(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MetaCallback_stopped<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Meta_getServer : public Callback_Meta_getServer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::ServerPrx&);

    CallbackNC_Meta_getServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ServerPrx __ret;
        try
        {
            __ret = __proxy->end_getServer(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Meta_getServerPtr
newCallback_Meta_getServer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getServer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Meta_getServerPtr
newCallback_Meta_getServer(T* instance, void (T::*cb)(const ::Murmur::ServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getServer<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Meta_getServer : public Callback_Meta_getServer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::ServerPrx&, const CT&);

    Callback_Meta_getServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ServerPrx __ret;
        try
        {
            __ret = __proxy->end_getServer(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Meta_getServerPtr
newCallback_Meta_getServer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_getServerPtr
newCallback_Meta_getServer(T* instance, void (T::*cb)(const ::Murmur::ServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Meta_newServer : public Callback_Meta_newServer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::ServerPrx&);

    CallbackNC_Meta_newServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ServerPrx __ret;
        try
        {
            __ret = __proxy->end_newServer(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Meta_newServerPtr
newCallback_Meta_newServer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_newServer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Meta_newServerPtr
newCallback_Meta_newServer(T* instance, void (T::*cb)(const ::Murmur::ServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_newServer<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Meta_newServer : public Callback_Meta_newServer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::ServerPrx&, const CT&);

    Callback_Meta_newServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ServerPrx __ret;
        try
        {
            __ret = __proxy->end_newServer(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Meta_newServerPtr
newCallback_Meta_newServer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_newServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_newServerPtr
newCallback_Meta_newServer(T* instance, void (T::*cb)(const ::Murmur::ServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_newServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Meta_getBootedServers : public Callback_Meta_getBootedServers_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::ServerList&);

    CallbackNC_Meta_getBootedServers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ServerList __ret;
        try
        {
            __ret = __proxy->end_getBootedServers(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Meta_getBootedServersPtr
newCallback_Meta_getBootedServers(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ServerList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getBootedServers<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Meta_getBootedServersPtr
newCallback_Meta_getBootedServers(T* instance, void (T::*cb)(const ::Murmur::ServerList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getBootedServers<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Meta_getBootedServers : public Callback_Meta_getBootedServers_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::ServerList&, const CT&);

    Callback_Meta_getBootedServers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ServerList __ret;
        try
        {
            __ret = __proxy->end_getBootedServers(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Meta_getBootedServersPtr
newCallback_Meta_getBootedServers(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ServerList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getBootedServers<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_getBootedServersPtr
newCallback_Meta_getBootedServers(T* instance, void (T::*cb)(const ::Murmur::ServerList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getBootedServers<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Meta_getAllServers : public Callback_Meta_getAllServers_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::ServerList&);

    CallbackNC_Meta_getAllServers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ServerList __ret;
        try
        {
            __ret = __proxy->end_getAllServers(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Meta_getAllServersPtr
newCallback_Meta_getAllServers(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ServerList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getAllServers<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Meta_getAllServersPtr
newCallback_Meta_getAllServers(T* instance, void (T::*cb)(const ::Murmur::ServerList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getAllServers<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Meta_getAllServers : public Callback_Meta_getAllServers_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::ServerList&, const CT&);

    Callback_Meta_getAllServers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ServerList __ret;
        try
        {
            __ret = __proxy->end_getAllServers(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Meta_getAllServersPtr
newCallback_Meta_getAllServers(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ServerList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getAllServers<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_getAllServersPtr
newCallback_Meta_getAllServers(T* instance, void (T::*cb)(const ::Murmur::ServerList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getAllServers<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Meta_getDefaultConf : public Callback_Meta_getDefaultConf_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Murmur::ConfigMap&);

    CallbackNC_Meta_getDefaultConf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ConfigMap __ret;
        try
        {
            __ret = __proxy->end_getDefaultConf(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Meta_getDefaultConfPtr
newCallback_Meta_getDefaultConf(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ConfigMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getDefaultConf<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Meta_getDefaultConfPtr
newCallback_Meta_getDefaultConf(T* instance, void (T::*cb)(const ::Murmur::ConfigMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getDefaultConf<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Meta_getDefaultConf : public Callback_Meta_getDefaultConf_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Murmur::ConfigMap&, const CT&);

    Callback_Meta_getDefaultConf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Murmur::ConfigMap __ret;
        try
        {
            __ret = __proxy->end_getDefaultConf(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Meta_getDefaultConfPtr
newCallback_Meta_getDefaultConf(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Murmur::ConfigMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getDefaultConf<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_getDefaultConfPtr
newCallback_Meta_getDefaultConf(T* instance, void (T::*cb)(const ::Murmur::ConfigMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getDefaultConf<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Meta_getVersion : public Callback_Meta_getVersion_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::std::string&);

    CallbackNC_Meta_getVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int major;
        ::Ice::Int minor;
        ::Ice::Int patch;
        ::std::string text;
        try
        {
            __proxy->end_getVersion(major, minor, patch, text, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(major, minor, patch, text);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(major, minor, patch, text);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Meta_getVersionPtr
newCallback_Meta_getVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getVersion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Meta_getVersionPtr
newCallback_Meta_getVersion(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getVersion<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Meta_getVersion : public Callback_Meta_getVersion_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::std::string&, const CT&);

    Callback_Meta_getVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int major;
        ::Ice::Int minor;
        ::Ice::Int patch;
        ::std::string text;
        try
        {
            __proxy->end_getVersion(major, minor, patch, text, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(major, minor, patch, text, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(major, minor, patch, text, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Meta_getVersionPtr
newCallback_Meta_getVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_getVersionPtr
newCallback_Meta_getVersion(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Meta_addCallback : public Callback_Meta_addCallback_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Meta_addCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addCallback(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Meta_addCallbackPtr
newCallback_Meta_addCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_addCallback<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Meta_addCallbackPtr
newCallback_Meta_addCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_addCallback<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Meta_addCallbackPtr
newCallback_Meta_addCallback(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_addCallback<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Meta_addCallbackPtr
newCallback_Meta_addCallback(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_addCallback<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Meta_addCallback : public Callback_Meta_addCallback_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Meta_addCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addCallback(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Meta_addCallbackPtr
newCallback_Meta_addCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_addCallback<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_addCallbackPtr
newCallback_Meta_addCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_addCallback<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_addCallbackPtr
newCallback_Meta_addCallback(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_addCallback<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_addCallbackPtr
newCallback_Meta_addCallback(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_addCallback<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Meta_removeCallback : public Callback_Meta_removeCallback_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Meta_removeCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_removeCallback(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Meta_removeCallbackPtr
newCallback_Meta_removeCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_removeCallback<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Meta_removeCallbackPtr
newCallback_Meta_removeCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_removeCallback<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Meta_removeCallbackPtr
newCallback_Meta_removeCallback(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_removeCallback<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Meta_removeCallbackPtr
newCallback_Meta_removeCallback(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_removeCallback<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Meta_removeCallback : public Callback_Meta_removeCallback_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Meta_removeCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_removeCallback(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Meta_removeCallbackPtr
newCallback_Meta_removeCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_removeCallback<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_removeCallbackPtr
newCallback_Meta_removeCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_removeCallback<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_removeCallbackPtr
newCallback_Meta_removeCallback(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_removeCallback<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_removeCallbackPtr
newCallback_Meta_removeCallback(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_removeCallback<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Meta_getUptime : public Callback_Meta_getUptime_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Meta_getUptime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getUptime(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Meta_getUptimePtr
newCallback_Meta_getUptime(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getUptime<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Meta_getUptimePtr
newCallback_Meta_getUptime(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getUptime<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Meta_getUptime : public Callback_Meta_getUptime_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Meta_getUptime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getUptime(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Meta_getUptimePtr
newCallback_Meta_getUptime(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getUptime<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_getUptimePtr
newCallback_Meta_getUptime(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getUptime<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Meta_getSlice : public Callback_Meta_getSlice_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Meta_getSlice(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getSlice(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Meta_getSlicePtr
newCallback_Meta_getSlice(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getSlice<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Meta_getSlicePtr
newCallback_Meta_getSlice(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getSlice<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Meta_getSlice : public Callback_Meta_getSlice_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Meta_getSlice(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getSlice(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Meta_getSlicePtr
newCallback_Meta_getSlice(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getSlice<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_getSlicePtr
newCallback_Meta_getSlice(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getSlice<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Meta_getSliceChecksums : public Callback_Meta_getSliceChecksums_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::SliceChecksumDict&);

    CallbackNC_Meta_getSliceChecksums(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Ice::SliceChecksumDict __ret;
        try
        {
            __ret = __proxy->end_getSliceChecksums(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Meta_getSliceChecksumsPtr
newCallback_Meta_getSliceChecksums(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::SliceChecksumDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getSliceChecksums<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Meta_getSliceChecksumsPtr
newCallback_Meta_getSliceChecksums(T* instance, void (T::*cb)(const ::Ice::SliceChecksumDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Meta_getSliceChecksums<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Meta_getSliceChecksums : public Callback_Meta_getSliceChecksums_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::SliceChecksumDict&, const CT&);

    Callback_Meta_getSliceChecksums(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Murmur::MetaPrx __proxy = ::Murmur::MetaPrx::uncheckedCast(__result->getProxy());
        ::Ice::SliceChecksumDict __ret;
        try
        {
            __ret = __proxy->end_getSliceChecksums(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Meta_getSliceChecksumsPtr
newCallback_Meta_getSliceChecksums(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::SliceChecksumDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getSliceChecksums<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Meta_getSliceChecksumsPtr
newCallback_Meta_getSliceChecksums(T* instance, void (T::*cb)(const ::Ice::SliceChecksumDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Meta_getSliceChecksums<T, CT>(instance, cb, excb, sentcb);
}

}

#endif
